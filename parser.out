Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BACKTICK
    BREAK
    CASE
    CONSTRUCTOR
    DEFAULT
    DOLLAR
    FOR
    INTERFACE
    PIPE
    PRIVATE
    PROTECTED
    PUBLIC
    QUESTION
    SWITCH
    THIS
    TYPE
    TYPEOF
    VOID
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement statement_list
Rule 4     statement -> assignment SEMICOLON
Rule 5     statement -> expression SEMICOLON
Rule 6     statement -> if_statement
Rule 7     statement -> function_def
Rule 8     statement -> return_statement
Rule 9     statement -> class_declaration
Rule 10    assignment -> LET IDENTIFIER EQUALS value
Rule 11    assignment -> LET IDENTIFIER COLON data_type EQUALS value
Rule 12    assignment -> LET IDENTIFIER COLON data_type
Rule 13    assignment -> CONST IDENTIFIER EQUALS value
Rule 14    assignment -> CONST IDENTIFIER COLON data_type EQUALS value
Rule 15    assignment -> VAR IDENTIFIER EQUALS value
Rule 16    assignment -> VAR IDENTIFIER COLON data_type EQUALS value
Rule 17    assignment -> VAR IDENTIFIER COLON data_type
Rule 18    assignment -> IDENTIFIER EQUALS value
Rule 19    data_type -> STRING_TYPE
Rule 20    data_type -> NUMBER_TYPE
Rule 21    data_type -> BOOLEAN_TYPE
Rule 22    data_type -> CHAR_TYPE
Rule 23    data_type -> array_type
Rule 24    data_type -> object_type_literal
Rule 25    value -> STRING
Rule 26    value -> CHARACTER
Rule 27    value -> array
Rule 28    value -> object_literal
Rule 29    value -> arithmetic_expression
Rule 30    value -> logical_expression
Rule 31    value -> expression
Rule 32    array_type -> NUMBER_TYPE LBRACKET RBRACKET
Rule 33    array_type -> STRING_TYPE LBRACKET RBRACKET
Rule 34    array_type -> BOOLEAN_TYPE LBRACKET RBRACKET
Rule 35    array_type -> ANY LBRACKET RBRACKET
Rule 36    array -> LBRACKET RBRACKET
Rule 37    array -> LBRACKET element_list RBRACKET
Rule 38    element_list -> value
Rule 39    element_list -> value COMMA element_list
Rule 40    object_type_literal -> LBRACE property_list RBRACE
Rule 41    object_type_literal -> LBRACE RBRACE
Rule 42    object_literal -> LBRACE property_assignment_list RBRACE
Rule 43    object_literal -> LBRACE RBRACE
Rule 44    property -> IDENTIFIER COLON data_type
Rule 45    property_assignment_list -> property_assignment
Rule 46    property_assignment_list -> property_assignment COMMA property_assignment_list
Rule 47    property_assignment -> IDENTIFIER COLON value
Rule 48    property_assignment -> STRING COLON value
Rule 49    property_list -> property
Rule 50    property_list -> property SEMICOLON property_list
Rule 51    arithmetic_expression -> arithmetic_expression PLUS term
Rule 52    arithmetic_expression -> arithmetic_expression MINUS term
Rule 53    arithmetic_expression -> term
Rule 54    term -> term TIMES factor
Rule 55    term -> term DIVIDE factor
Rule 56    term -> term MODULE factor
Rule 57    term -> factor
Rule 58    factor -> atom POWER factor
Rule 59    factor -> atom
Rule 60    atom -> NUMBER
Rule 61    atom -> IDENTIFIER
Rule 62    atom -> LPAREN arithmetic_expression RPAREN
Rule 63    logical_expression -> logical_expression AND logical_term
Rule 64    logical_expression -> logical_expression OR logical_term
Rule 65    logical_expression -> logical_term
Rule 66    logical_term -> NOT logical_factor
Rule 67    logical_term -> logical_factor
Rule 68    logical_factor -> comparison_expression
Rule 69    logical_factor -> IDENTIFIER
Rule 70    logical_factor -> TRUE
Rule 71    logical_factor -> FALSE
Rule 72    logical_factor -> LPAREN logical_expression RPAREN
Rule 73    comparison_expression -> arithmetic_expression EQEQ arithmetic_expression
Rule 74    comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression
Rule 75    comparison_expression -> arithmetic_expression GT arithmetic_expression
Rule 76    comparison_expression -> arithmetic_expression LT arithmetic_expression
Rule 77    comparison_expression -> arithmetic_expression GE arithmetic_expression
Rule 78    comparison_expression -> arithmetic_expression LE arithmetic_expression
Rule 79    expression -> expression DOT IDENTIFIER
Rule 80    expression -> IDENTIFIER DOT IDENTIFIER
Rule 81    expression -> IDENTIFIER LPAREN RPAREN
Rule 82    expression -> IDENTIFIER LPAREN argument_list RPAREN
Rule 83    argument_list -> expression
Rule 84    argument_list -> expression COMMA argument_list
Rule 85    class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE
Rule 86    class_body -> class_member_list
Rule 87    class_body -> empty
Rule 88    class_member_list -> class_member
Rule 89    class_member_list -> class_member class_member_list
Rule 90    class_member -> assignment
Rule 91    class_member -> function_def
Rule 92    class_member -> property
Rule 93    empty -> <empty>
Rule 94    function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block
Rule 95    function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
Rule 96    param_list -> IDENTIFIER
Rule 97    param_list -> IDENTIFIER COMMA param_list
Rule 98    return_statement -> RETURN expression SEMICOLON
Rule 99    statement_block -> LBRACE statement_list RBRACE
Rule 100   statement_block -> statement
Rule 101   if_statement -> IF LPAREN logical_expression RPAREN statement_block
Rule 102   if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block

Terminals, with rules where they appear

AND                  : 63
ANY                  : 35
ARROW                : 
BACKTICK             : 
BOOLEAN_TYPE         : 21 34
BREAK                : 
CASE                 : 
CHARACTER            : 26
CHAR_TYPE            : 22
CLASS                : 85
COLON                : 11 12 14 16 17 44 47 48
COMMA                : 39 46 84 97
CONST                : 13 14
CONSTRUCTOR          : 
DEFAULT              : 
DIVIDE               : 55
DOLLAR               : 
DOT                  : 79 80
ELSE                 : 102
EQEQ                 : 73
EQUALS               : 10 11 13 14 15 16 18
FALSE                : 71
FOR                  : 
FUNCTION             : 94 95
GE                   : 77
GT                   : 75
IDENTIFIER           : 10 11 12 13 14 15 16 17 18 44 47 61 69 79 80 80 81 82 85 94 95 96 97
IF                   : 101 102
INTERFACE            : 
LBRACE               : 40 41 42 43 85 99
LBRACKET             : 32 33 34 35 36 37
LE                   : 78
LET                  : 10 11 12
LPAREN               : 62 72 81 82 94 95 101 102
LT                   : 76
MINUS                : 52
MODULE               : 56
NOT                  : 66
NOTEQ                : 74
NUMBER               : 60
NUMBER_TYPE          : 20 32
OR                   : 64
PIPE                 : 
PLUS                 : 51
POWER                : 58
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUESTION             : 
RBRACE               : 40 41 42 43 85 99
RBRACKET             : 32 33 34 35 36 37
RETURN               : 98
RPAREN               : 62 72 81 82 94 95 101 102
SEMICOLON            : 4 5 50 98
STRING               : 25 48
STRING_TYPE          : 19 33
SWITCH               : 
THIS                 : 
TIMES                : 54
TRUE                 : 70
TYPE                 : 
TYPEOF               : 
VAR                  : 15 16 17
VOID                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 82 84
arithmetic_expression : 29 51 52 62 73 73 74 74 75 75 76 76 77 77 78 78
array                : 27
array_type           : 23
assignment           : 4 90
atom                 : 58 59
class_body           : 85
class_declaration    : 9
class_member         : 88 89
class_member_list    : 86 89
comparison_expression : 68
data_type            : 11 12 14 16 17 44
element_list         : 37 39
empty                : 87
expression           : 5 31 79 83 84 98
factor               : 54 55 56 57 58
function_def         : 7 91
if_statement         : 6
logical_expression   : 30 63 64 72 101 102
logical_factor       : 66 67
logical_term         : 63 64 65
object_literal       : 28
object_type_literal  : 24
param_list           : 95 97
program              : 0
property             : 49 50 92
property_assignment  : 45 46
property_assignment_list : 42 46
property_list        : 40 50
return_statement     : 8
statement            : 2 3 100
statement_block      : 94 95 101 102 102
statement_list       : 1 3 99
term                 : 51 52 53 54 55 56
value                : 10 11 13 14 15 16 18 38 39 47 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement statement_list
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .

    $end            reduce using rule 1 (program -> statement_list .)


state 3

    (2) statement_list -> statement .
    (3) statement_list -> statement . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement statement_list
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement .)
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    statement                      shift and go to state 3
    statement_list                 shift and go to state 18
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 4

    (4) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 19


state 5

    (5) statement -> expression . SEMICOLON
    (79) expression -> expression . DOT IDENTIFIER

    SEMICOLON       shift and go to state 20
    DOT             shift and go to state 21


state 6

    (6) statement -> if_statement .

    LET             reduce using rule 6 (statement -> if_statement .)
    CONST           reduce using rule 6 (statement -> if_statement .)
    VAR             reduce using rule 6 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    FUNCTION        reduce using rule 6 (statement -> if_statement .)
    RETURN          reduce using rule 6 (statement -> if_statement .)
    CLASS           reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    RBRACE          reduce using rule 6 (statement -> if_statement .)
    ELSE            reduce using rule 6 (statement -> if_statement .)


state 7

    (7) statement -> function_def .

    LET             reduce using rule 7 (statement -> function_def .)
    CONST           reduce using rule 7 (statement -> function_def .)
    VAR             reduce using rule 7 (statement -> function_def .)
    IDENTIFIER      reduce using rule 7 (statement -> function_def .)
    IF              reduce using rule 7 (statement -> function_def .)
    FUNCTION        reduce using rule 7 (statement -> function_def .)
    RETURN          reduce using rule 7 (statement -> function_def .)
    CLASS           reduce using rule 7 (statement -> function_def .)
    $end            reduce using rule 7 (statement -> function_def .)
    RBRACE          reduce using rule 7 (statement -> function_def .)
    ELSE            reduce using rule 7 (statement -> function_def .)


state 8

    (8) statement -> return_statement .

    LET             reduce using rule 8 (statement -> return_statement .)
    CONST           reduce using rule 8 (statement -> return_statement .)
    VAR             reduce using rule 8 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 8 (statement -> return_statement .)
    IF              reduce using rule 8 (statement -> return_statement .)
    FUNCTION        reduce using rule 8 (statement -> return_statement .)
    RETURN          reduce using rule 8 (statement -> return_statement .)
    CLASS           reduce using rule 8 (statement -> return_statement .)
    $end            reduce using rule 8 (statement -> return_statement .)
    RBRACE          reduce using rule 8 (statement -> return_statement .)
    ELSE            reduce using rule 8 (statement -> return_statement .)


state 9

    (9) statement -> class_declaration .

    LET             reduce using rule 9 (statement -> class_declaration .)
    CONST           reduce using rule 9 (statement -> class_declaration .)
    VAR             reduce using rule 9 (statement -> class_declaration .)
    IDENTIFIER      reduce using rule 9 (statement -> class_declaration .)
    IF              reduce using rule 9 (statement -> class_declaration .)
    FUNCTION        reduce using rule 9 (statement -> class_declaration .)
    RETURN          reduce using rule 9 (statement -> class_declaration .)
    CLASS           reduce using rule 9 (statement -> class_declaration .)
    $end            reduce using rule 9 (statement -> class_declaration .)
    RBRACE          reduce using rule 9 (statement -> class_declaration .)
    ELSE            reduce using rule 9 (statement -> class_declaration .)


state 10

    (10) assignment -> LET . IDENTIFIER EQUALS value
    (11) assignment -> LET . IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> LET . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 22


state 11

    (18) assignment -> IDENTIFIER . EQUALS value
    (80) expression -> IDENTIFIER . DOT IDENTIFIER
    (81) expression -> IDENTIFIER . LPAREN RPAREN
    (82) expression -> IDENTIFIER . LPAREN argument_list RPAREN

    EQUALS          shift and go to state 23
    DOT             shift and go to state 24
    LPAREN          shift and go to state 25


state 12

    (13) assignment -> CONST . IDENTIFIER EQUALS value
    (14) assignment -> CONST . IDENTIFIER COLON data_type EQUALS value

    IDENTIFIER      shift and go to state 26


state 13

    (15) assignment -> VAR . IDENTIFIER EQUALS value
    (16) assignment -> VAR . IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> VAR . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 27


state 14

    (101) if_statement -> IF . LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> IF . LPAREN logical_expression RPAREN statement_block ELSE statement_block

    LPAREN          shift and go to state 28


state 15

    (94) function_def -> FUNCTION . IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> FUNCTION . IDENTIFIER LPAREN param_list RPAREN statement_block

    IDENTIFIER      shift and go to state 29


state 16

    (98) return_statement -> RETURN . expression SEMICOLON
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 31

    expression                     shift and go to state 30

state 17

    (85) class_declaration -> CLASS . IDENTIFIER LBRACE class_body RBRACE

    IDENTIFIER      shift and go to state 32


state 18

    (3) statement_list -> statement statement_list .

    $end            reduce using rule 3 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 3 (statement_list -> statement statement_list .)


state 19

    (4) statement -> assignment SEMICOLON .

    LET             reduce using rule 4 (statement -> assignment SEMICOLON .)
    CONST           reduce using rule 4 (statement -> assignment SEMICOLON .)
    VAR             reduce using rule 4 (statement -> assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 4 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 4 (statement -> assignment SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 4 (statement -> assignment SEMICOLON .)
    CLASS           reduce using rule 4 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 4 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> assignment SEMICOLON .)
    ELSE            reduce using rule 4 (statement -> assignment SEMICOLON .)


state 20

    (5) statement -> expression SEMICOLON .

    LET             reduce using rule 5 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 5 (statement -> expression SEMICOLON .)
    VAR             reduce using rule 5 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 5 (statement -> expression SEMICOLON .)
    IF              reduce using rule 5 (statement -> expression SEMICOLON .)
    FUNCTION        reduce using rule 5 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 5 (statement -> expression SEMICOLON .)
    CLASS           reduce using rule 5 (statement -> expression SEMICOLON .)
    $end            reduce using rule 5 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 5 (statement -> expression SEMICOLON .)
    ELSE            reduce using rule 5 (statement -> expression SEMICOLON .)


state 21

    (79) expression -> expression DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 33


state 22

    (10) assignment -> LET IDENTIFIER . EQUALS value
    (11) assignment -> LET IDENTIFIER . COLON data_type EQUALS value
    (12) assignment -> LET IDENTIFIER . COLON data_type

    EQUALS          shift and go to state 34
    COLON           shift and go to state 35


state 23

    (18) assignment -> IDENTIFIER EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 37
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 24

    (80) expression -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 58


state 25

    (81) expression -> IDENTIFIER LPAREN . RPAREN
    (82) expression -> IDENTIFIER LPAREN . argument_list RPAREN
    (83) argument_list -> . expression
    (84) argument_list -> . expression COMMA argument_list
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN

    RPAREN          shift and go to state 59
    IDENTIFIER      shift and go to state 31

    argument_list                  shift and go to state 60
    expression                     shift and go to state 61

state 26

    (13) assignment -> CONST IDENTIFIER . EQUALS value
    (14) assignment -> CONST IDENTIFIER . COLON data_type EQUALS value

    EQUALS          shift and go to state 62
    COLON           shift and go to state 63


state 27

    (15) assignment -> VAR IDENTIFIER . EQUALS value
    (16) assignment -> VAR IDENTIFIER . COLON data_type EQUALS value
    (17) assignment -> VAR IDENTIFIER . COLON data_type

    EQUALS          shift and go to state 64
    COLON           shift and go to state 65


state 28

    (101) if_statement -> IF LPAREN . logical_expression RPAREN statement_block
    (102) if_statement -> IF LPAREN . logical_expression RPAREN statement_block ELSE statement_block
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 51
    IDENTIFIER      shift and go to state 67
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    logical_expression             shift and go to state 66
    logical_term                   shift and go to state 48
    logical_factor                 shift and go to state 52
    comparison_expression          shift and go to state 54
    arithmetic_expression          shift and go to state 68
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 29

    (94) function_def -> FUNCTION IDENTIFIER . LPAREN RPAREN statement_block
    (95) function_def -> FUNCTION IDENTIFIER . LPAREN param_list RPAREN statement_block

    LPAREN          shift and go to state 69


state 30

    (98) return_statement -> RETURN expression . SEMICOLON
    (79) expression -> expression . DOT IDENTIFIER

    SEMICOLON       shift and go to state 70
    DOT             shift and go to state 21


state 31

    (80) expression -> IDENTIFIER . DOT IDENTIFIER
    (81) expression -> IDENTIFIER . LPAREN RPAREN
    (82) expression -> IDENTIFIER . LPAREN argument_list RPAREN

    DOT             shift and go to state 24
    LPAREN          shift and go to state 25


state 32

    (85) class_declaration -> CLASS IDENTIFIER . LBRACE class_body RBRACE

    LBRACE          shift and go to state 71


state 33

    (79) expression -> expression DOT IDENTIFIER .

    SEMICOLON       reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    DOT             reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    LET             reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    CONST           reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    VAR             reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    FUNCTION        reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    RBRACE          reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    COMMA           reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    RPAREN          reduce using rule 79 (expression -> expression DOT IDENTIFIER .)
    RBRACKET        reduce using rule 79 (expression -> expression DOT IDENTIFIER .)


state 34

    (10) assignment -> LET IDENTIFIER EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 72
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 35

    (11) assignment -> LET IDENTIFIER COLON . data_type EQUALS value
    (12) assignment -> LET IDENTIFIER COLON . data_type
    (19) data_type -> . STRING_TYPE
    (20) data_type -> . NUMBER_TYPE
    (21) data_type -> . BOOLEAN_TYPE
    (22) data_type -> . CHAR_TYPE
    (23) data_type -> . array_type
    (24) data_type -> . object_type_literal
    (32) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (33) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (34) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (35) array_type -> . ANY LBRACKET RBRACKET
    (40) object_type_literal -> . LBRACE property_list RBRACE
    (41) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 74
    NUMBER_TYPE     shift and go to state 75
    BOOLEAN_TYPE    shift and go to state 76
    CHAR_TYPE       shift and go to state 77
    ANY             shift and go to state 80
    LBRACE          shift and go to state 81

    data_type                      shift and go to state 73
    array_type                     shift and go to state 78
    object_type_literal            shift and go to state 79

state 36

    (80) expression -> IDENTIFIER . DOT IDENTIFIER
    (81) expression -> IDENTIFIER . LPAREN RPAREN
    (82) expression -> IDENTIFIER . LPAREN argument_list RPAREN
    (69) logical_factor -> IDENTIFIER .
    (61) atom -> IDENTIFIER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for LET resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for CONST resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for FUNCTION resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 61 (atom -> IDENTIFIER .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 61 (atom -> IDENTIFIER .)
    DOT             shift and go to state 24
    LPAREN          shift and go to state 25
    AND             reduce using rule 69 (logical_factor -> IDENTIFIER .)
    OR              reduce using rule 69 (logical_factor -> IDENTIFIER .)
    POWER           reduce using rule 61 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 61 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (atom -> IDENTIFIER .)
    MODULE          reduce using rule 61 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 61 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 61 (atom -> IDENTIFIER .)
    EQEQ            reduce using rule 61 (atom -> IDENTIFIER .)
    NOTEQ           reduce using rule 61 (atom -> IDENTIFIER .)
    GT              reduce using rule 61 (atom -> IDENTIFIER .)
    LT              reduce using rule 61 (atom -> IDENTIFIER .)
    GE              reduce using rule 61 (atom -> IDENTIFIER .)
    LE              reduce using rule 61 (atom -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (atom -> IDENTIFIER .)
    LET             reduce using rule 61 (atom -> IDENTIFIER .)
    CONST           reduce using rule 61 (atom -> IDENTIFIER .)
    VAR             reduce using rule 61 (atom -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 61 (atom -> IDENTIFIER .)
    FUNCTION        reduce using rule 61 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 61 (atom -> IDENTIFIER .)
    COMMA           reduce using rule 61 (atom -> IDENTIFIER .)
    RBRACKET        reduce using rule 61 (atom -> IDENTIFIER .)

  ! SEMICOLON       [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! LET             [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! CONST           [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! VAR             [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! FUNCTION        [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! RBRACE          [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]
  ! RBRACKET        [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]


state 37

    (18) assignment -> IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)
    LET             reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)
    CONST           reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)
    VAR             reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)
    IDENTIFIER      reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)
    FUNCTION        reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)
    RBRACE          reduce using rule 18 (assignment -> IDENTIFIER EQUALS value .)


state 38

    (25) value -> STRING .

    SEMICOLON       reduce using rule 25 (value -> STRING .)
    LET             reduce using rule 25 (value -> STRING .)
    CONST           reduce using rule 25 (value -> STRING .)
    VAR             reduce using rule 25 (value -> STRING .)
    IDENTIFIER      reduce using rule 25 (value -> STRING .)
    FUNCTION        reduce using rule 25 (value -> STRING .)
    RBRACE          reduce using rule 25 (value -> STRING .)
    COMMA           reduce using rule 25 (value -> STRING .)
    RBRACKET        reduce using rule 25 (value -> STRING .)


state 39

    (26) value -> CHARACTER .

    SEMICOLON       reduce using rule 26 (value -> CHARACTER .)
    LET             reduce using rule 26 (value -> CHARACTER .)
    CONST           reduce using rule 26 (value -> CHARACTER .)
    VAR             reduce using rule 26 (value -> CHARACTER .)
    IDENTIFIER      reduce using rule 26 (value -> CHARACTER .)
    FUNCTION        reduce using rule 26 (value -> CHARACTER .)
    RBRACE          reduce using rule 26 (value -> CHARACTER .)
    COMMA           reduce using rule 26 (value -> CHARACTER .)
    RBRACKET        reduce using rule 26 (value -> CHARACTER .)


state 40

    (27) value -> array .

    SEMICOLON       reduce using rule 27 (value -> array .)
    LET             reduce using rule 27 (value -> array .)
    CONST           reduce using rule 27 (value -> array .)
    VAR             reduce using rule 27 (value -> array .)
    IDENTIFIER      reduce using rule 27 (value -> array .)
    FUNCTION        reduce using rule 27 (value -> array .)
    RBRACE          reduce using rule 27 (value -> array .)
    COMMA           reduce using rule 27 (value -> array .)
    RBRACKET        reduce using rule 27 (value -> array .)


state 41

    (28) value -> object_literal .

    SEMICOLON       reduce using rule 28 (value -> object_literal .)
    LET             reduce using rule 28 (value -> object_literal .)
    CONST           reduce using rule 28 (value -> object_literal .)
    VAR             reduce using rule 28 (value -> object_literal .)
    IDENTIFIER      reduce using rule 28 (value -> object_literal .)
    FUNCTION        reduce using rule 28 (value -> object_literal .)
    RBRACE          reduce using rule 28 (value -> object_literal .)
    COMMA           reduce using rule 28 (value -> object_literal .)
    RBRACKET        reduce using rule 28 (value -> object_literal .)


state 42

    (29) value -> arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term
    (73) comparison_expression -> arithmetic_expression . EQEQ arithmetic_expression
    (74) comparison_expression -> arithmetic_expression . NOTEQ arithmetic_expression
    (75) comparison_expression -> arithmetic_expression . GT arithmetic_expression
    (76) comparison_expression -> arithmetic_expression . LT arithmetic_expression
    (77) comparison_expression -> arithmetic_expression . GE arithmetic_expression
    (78) comparison_expression -> arithmetic_expression . LE arithmetic_expression

    SEMICOLON       reduce using rule 29 (value -> arithmetic_expression .)
    LET             reduce using rule 29 (value -> arithmetic_expression .)
    CONST           reduce using rule 29 (value -> arithmetic_expression .)
    VAR             reduce using rule 29 (value -> arithmetic_expression .)
    IDENTIFIER      reduce using rule 29 (value -> arithmetic_expression .)
    FUNCTION        reduce using rule 29 (value -> arithmetic_expression .)
    RBRACE          reduce using rule 29 (value -> arithmetic_expression .)
    COMMA           reduce using rule 29 (value -> arithmetic_expression .)
    RBRACKET        reduce using rule 29 (value -> arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    EQEQ            shift and go to state 84
    NOTEQ           shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    GE              shift and go to state 88
    LE              shift and go to state 89


state 43

    (30) value -> logical_expression .
    (63) logical_expression -> logical_expression . AND logical_term
    (64) logical_expression -> logical_expression . OR logical_term

    SEMICOLON       reduce using rule 30 (value -> logical_expression .)
    LET             reduce using rule 30 (value -> logical_expression .)
    CONST           reduce using rule 30 (value -> logical_expression .)
    VAR             reduce using rule 30 (value -> logical_expression .)
    IDENTIFIER      reduce using rule 30 (value -> logical_expression .)
    FUNCTION        reduce using rule 30 (value -> logical_expression .)
    RBRACE          reduce using rule 30 (value -> logical_expression .)
    COMMA           reduce using rule 30 (value -> logical_expression .)
    RBRACKET        reduce using rule 30 (value -> logical_expression .)
    AND             shift and go to state 90
    OR              shift and go to state 91


state 44

    (31) value -> expression .
    (79) expression -> expression . DOT IDENTIFIER

    SEMICOLON       reduce using rule 31 (value -> expression .)
    LET             reduce using rule 31 (value -> expression .)
    CONST           reduce using rule 31 (value -> expression .)
    VAR             reduce using rule 31 (value -> expression .)
    IDENTIFIER      reduce using rule 31 (value -> expression .)
    FUNCTION        reduce using rule 31 (value -> expression .)
    RBRACE          reduce using rule 31 (value -> expression .)
    COMMA           reduce using rule 31 (value -> expression .)
    RBRACKET        reduce using rule 31 (value -> expression .)
    DOT             shift and go to state 21


state 45

    (36) array -> LBRACKET . RBRACKET
    (37) array -> LBRACKET . element_list RBRACKET
    (38) element_list -> . value
    (39) element_list -> . value COMMA element_list
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    RBRACKET        shift and go to state 92
    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    element_list                   shift and go to state 93
    value                          shift and go to state 94
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 46

    (42) object_literal -> LBRACE . property_assignment_list RBRACE
    (43) object_literal -> LBRACE . RBRACE
    (45) property_assignment_list -> . property_assignment
    (46) property_assignment_list -> . property_assignment COMMA property_assignment_list
    (47) property_assignment -> . IDENTIFIER COLON value
    (48) property_assignment -> . STRING COLON value

    RBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 98
    STRING          shift and go to state 99

    property_assignment_list       shift and go to state 95
    property_assignment            shift and go to state 97

state 47

    (53) arithmetic_expression -> term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor
    (56) term -> term . MODULE factor

    PLUS            reduce using rule 53 (arithmetic_expression -> term .)
    MINUS           reduce using rule 53 (arithmetic_expression -> term .)
    EQEQ            reduce using rule 53 (arithmetic_expression -> term .)
    NOTEQ           reduce using rule 53 (arithmetic_expression -> term .)
    GT              reduce using rule 53 (arithmetic_expression -> term .)
    LT              reduce using rule 53 (arithmetic_expression -> term .)
    GE              reduce using rule 53 (arithmetic_expression -> term .)
    LE              reduce using rule 53 (arithmetic_expression -> term .)
    SEMICOLON       reduce using rule 53 (arithmetic_expression -> term .)
    LET             reduce using rule 53 (arithmetic_expression -> term .)
    CONST           reduce using rule 53 (arithmetic_expression -> term .)
    VAR             reduce using rule 53 (arithmetic_expression -> term .)
    IDENTIFIER      reduce using rule 53 (arithmetic_expression -> term .)
    FUNCTION        reduce using rule 53 (arithmetic_expression -> term .)
    RBRACE          reduce using rule 53 (arithmetic_expression -> term .)
    COMMA           reduce using rule 53 (arithmetic_expression -> term .)
    RBRACKET        reduce using rule 53 (arithmetic_expression -> term .)
    RPAREN          reduce using rule 53 (arithmetic_expression -> term .)
    AND             reduce using rule 53 (arithmetic_expression -> term .)
    OR              reduce using rule 53 (arithmetic_expression -> term .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102


state 48

    (65) logical_expression -> logical_term .

    AND             reduce using rule 65 (logical_expression -> logical_term .)
    OR              reduce using rule 65 (logical_expression -> logical_term .)
    SEMICOLON       reduce using rule 65 (logical_expression -> logical_term .)
    LET             reduce using rule 65 (logical_expression -> logical_term .)
    CONST           reduce using rule 65 (logical_expression -> logical_term .)
    VAR             reduce using rule 65 (logical_expression -> logical_term .)
    IDENTIFIER      reduce using rule 65 (logical_expression -> logical_term .)
    FUNCTION        reduce using rule 65 (logical_expression -> logical_term .)
    RBRACE          reduce using rule 65 (logical_expression -> logical_term .)
    RPAREN          reduce using rule 65 (logical_expression -> logical_term .)
    COMMA           reduce using rule 65 (logical_expression -> logical_term .)
    RBRACKET        reduce using rule 65 (logical_expression -> logical_term .)


state 49

    (72) logical_factor -> LPAREN . logical_expression RPAREN
    (62) atom -> LPAREN . arithmetic_expression RPAREN
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 51
    IDENTIFIER      shift and go to state 67
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    logical_expression             shift and go to state 103
    arithmetic_expression          shift and go to state 104
    logical_term                   shift and go to state 48
    term                           shift and go to state 47
    logical_factor                 shift and go to state 52
    factor                         shift and go to state 50
    comparison_expression          shift and go to state 54
    atom                           shift and go to state 53

state 50

    (57) term -> factor .

    TIMES           reduce using rule 57 (term -> factor .)
    DIVIDE          reduce using rule 57 (term -> factor .)
    MODULE          reduce using rule 57 (term -> factor .)
    PLUS            reduce using rule 57 (term -> factor .)
    MINUS           reduce using rule 57 (term -> factor .)
    EQEQ            reduce using rule 57 (term -> factor .)
    NOTEQ           reduce using rule 57 (term -> factor .)
    GT              reduce using rule 57 (term -> factor .)
    LT              reduce using rule 57 (term -> factor .)
    GE              reduce using rule 57 (term -> factor .)
    LE              reduce using rule 57 (term -> factor .)
    SEMICOLON       reduce using rule 57 (term -> factor .)
    LET             reduce using rule 57 (term -> factor .)
    CONST           reduce using rule 57 (term -> factor .)
    VAR             reduce using rule 57 (term -> factor .)
    IDENTIFIER      reduce using rule 57 (term -> factor .)
    FUNCTION        reduce using rule 57 (term -> factor .)
    RBRACE          reduce using rule 57 (term -> factor .)
    COMMA           reduce using rule 57 (term -> factor .)
    RBRACKET        reduce using rule 57 (term -> factor .)
    RPAREN          reduce using rule 57 (term -> factor .)
    AND             reduce using rule 57 (term -> factor .)
    OR              reduce using rule 57 (term -> factor .)


state 51

    (66) logical_term -> NOT . logical_factor
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    IDENTIFIER      shift and go to state 67
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    logical_factor                 shift and go to state 105
    comparison_expression          shift and go to state 54
    arithmetic_expression          shift and go to state 68
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 52

    (67) logical_term -> logical_factor .

    AND             reduce using rule 67 (logical_term -> logical_factor .)
    OR              reduce using rule 67 (logical_term -> logical_factor .)
    SEMICOLON       reduce using rule 67 (logical_term -> logical_factor .)
    LET             reduce using rule 67 (logical_term -> logical_factor .)
    CONST           reduce using rule 67 (logical_term -> logical_factor .)
    VAR             reduce using rule 67 (logical_term -> logical_factor .)
    IDENTIFIER      reduce using rule 67 (logical_term -> logical_factor .)
    FUNCTION        reduce using rule 67 (logical_term -> logical_factor .)
    RBRACE          reduce using rule 67 (logical_term -> logical_factor .)
    RPAREN          reduce using rule 67 (logical_term -> logical_factor .)
    COMMA           reduce using rule 67 (logical_term -> logical_factor .)
    RBRACKET        reduce using rule 67 (logical_term -> logical_factor .)


state 53

    (58) factor -> atom . POWER factor
    (59) factor -> atom .

    POWER           shift and go to state 106
    TIMES           reduce using rule 59 (factor -> atom .)
    DIVIDE          reduce using rule 59 (factor -> atom .)
    MODULE          reduce using rule 59 (factor -> atom .)
    PLUS            reduce using rule 59 (factor -> atom .)
    MINUS           reduce using rule 59 (factor -> atom .)
    EQEQ            reduce using rule 59 (factor -> atom .)
    NOTEQ           reduce using rule 59 (factor -> atom .)
    GT              reduce using rule 59 (factor -> atom .)
    LT              reduce using rule 59 (factor -> atom .)
    GE              reduce using rule 59 (factor -> atom .)
    LE              reduce using rule 59 (factor -> atom .)
    SEMICOLON       reduce using rule 59 (factor -> atom .)
    LET             reduce using rule 59 (factor -> atom .)
    CONST           reduce using rule 59 (factor -> atom .)
    VAR             reduce using rule 59 (factor -> atom .)
    IDENTIFIER      reduce using rule 59 (factor -> atom .)
    FUNCTION        reduce using rule 59 (factor -> atom .)
    RBRACE          reduce using rule 59 (factor -> atom .)
    COMMA           reduce using rule 59 (factor -> atom .)
    RBRACKET        reduce using rule 59 (factor -> atom .)
    RPAREN          reduce using rule 59 (factor -> atom .)
    AND             reduce using rule 59 (factor -> atom .)
    OR              reduce using rule 59 (factor -> atom .)


state 54

    (68) logical_factor -> comparison_expression .

    AND             reduce using rule 68 (logical_factor -> comparison_expression .)
    OR              reduce using rule 68 (logical_factor -> comparison_expression .)
    SEMICOLON       reduce using rule 68 (logical_factor -> comparison_expression .)
    LET             reduce using rule 68 (logical_factor -> comparison_expression .)
    CONST           reduce using rule 68 (logical_factor -> comparison_expression .)
    VAR             reduce using rule 68 (logical_factor -> comparison_expression .)
    IDENTIFIER      reduce using rule 68 (logical_factor -> comparison_expression .)
    FUNCTION        reduce using rule 68 (logical_factor -> comparison_expression .)
    RBRACE          reduce using rule 68 (logical_factor -> comparison_expression .)
    RPAREN          reduce using rule 68 (logical_factor -> comparison_expression .)
    COMMA           reduce using rule 68 (logical_factor -> comparison_expression .)
    RBRACKET        reduce using rule 68 (logical_factor -> comparison_expression .)


state 55

    (70) logical_factor -> TRUE .

    AND             reduce using rule 70 (logical_factor -> TRUE .)
    OR              reduce using rule 70 (logical_factor -> TRUE .)
    SEMICOLON       reduce using rule 70 (logical_factor -> TRUE .)
    LET             reduce using rule 70 (logical_factor -> TRUE .)
    CONST           reduce using rule 70 (logical_factor -> TRUE .)
    VAR             reduce using rule 70 (logical_factor -> TRUE .)
    IDENTIFIER      reduce using rule 70 (logical_factor -> TRUE .)
    FUNCTION        reduce using rule 70 (logical_factor -> TRUE .)
    RBRACE          reduce using rule 70 (logical_factor -> TRUE .)
    RPAREN          reduce using rule 70 (logical_factor -> TRUE .)
    COMMA           reduce using rule 70 (logical_factor -> TRUE .)
    RBRACKET        reduce using rule 70 (logical_factor -> TRUE .)


state 56

    (71) logical_factor -> FALSE .

    AND             reduce using rule 71 (logical_factor -> FALSE .)
    OR              reduce using rule 71 (logical_factor -> FALSE .)
    SEMICOLON       reduce using rule 71 (logical_factor -> FALSE .)
    LET             reduce using rule 71 (logical_factor -> FALSE .)
    CONST           reduce using rule 71 (logical_factor -> FALSE .)
    VAR             reduce using rule 71 (logical_factor -> FALSE .)
    IDENTIFIER      reduce using rule 71 (logical_factor -> FALSE .)
    FUNCTION        reduce using rule 71 (logical_factor -> FALSE .)
    RBRACE          reduce using rule 71 (logical_factor -> FALSE .)
    RPAREN          reduce using rule 71 (logical_factor -> FALSE .)
    COMMA           reduce using rule 71 (logical_factor -> FALSE .)
    RBRACKET        reduce using rule 71 (logical_factor -> FALSE .)


state 57

    (60) atom -> NUMBER .

    POWER           reduce using rule 60 (atom -> NUMBER .)
    TIMES           reduce using rule 60 (atom -> NUMBER .)
    DIVIDE          reduce using rule 60 (atom -> NUMBER .)
    MODULE          reduce using rule 60 (atom -> NUMBER .)
    PLUS            reduce using rule 60 (atom -> NUMBER .)
    MINUS           reduce using rule 60 (atom -> NUMBER .)
    EQEQ            reduce using rule 60 (atom -> NUMBER .)
    NOTEQ           reduce using rule 60 (atom -> NUMBER .)
    GT              reduce using rule 60 (atom -> NUMBER .)
    LT              reduce using rule 60 (atom -> NUMBER .)
    GE              reduce using rule 60 (atom -> NUMBER .)
    LE              reduce using rule 60 (atom -> NUMBER .)
    SEMICOLON       reduce using rule 60 (atom -> NUMBER .)
    LET             reduce using rule 60 (atom -> NUMBER .)
    CONST           reduce using rule 60 (atom -> NUMBER .)
    VAR             reduce using rule 60 (atom -> NUMBER .)
    IDENTIFIER      reduce using rule 60 (atom -> NUMBER .)
    FUNCTION        reduce using rule 60 (atom -> NUMBER .)
    RBRACE          reduce using rule 60 (atom -> NUMBER .)
    COMMA           reduce using rule 60 (atom -> NUMBER .)
    RBRACKET        reduce using rule 60 (atom -> NUMBER .)
    RPAREN          reduce using rule 60 (atom -> NUMBER .)
    AND             reduce using rule 60 (atom -> NUMBER .)
    OR              reduce using rule 60 (atom -> NUMBER .)


state 58

    (80) expression -> IDENTIFIER DOT IDENTIFIER .

    SEMICOLON       reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    DOT             reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    LET             reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    CONST           reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    VAR             reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    FUNCTION        reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RBRACE          reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RPAREN          reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)
    RBRACKET        reduce using rule 80 (expression -> IDENTIFIER DOT IDENTIFIER .)


state 59

    (81) expression -> IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    DOT             reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    LET             reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    CONST           reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    VAR             reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    FUNCTION        reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 81 (expression -> IDENTIFIER LPAREN RPAREN .)


state 60

    (82) expression -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 107


state 61

    (83) argument_list -> expression .
    (84) argument_list -> expression . COMMA argument_list
    (79) expression -> expression . DOT IDENTIFIER

    RPAREN          reduce using rule 83 (argument_list -> expression .)
    COMMA           shift and go to state 108
    DOT             shift and go to state 21


state 62

    (13) assignment -> CONST IDENTIFIER EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 109
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 63

    (14) assignment -> CONST IDENTIFIER COLON . data_type EQUALS value
    (19) data_type -> . STRING_TYPE
    (20) data_type -> . NUMBER_TYPE
    (21) data_type -> . BOOLEAN_TYPE
    (22) data_type -> . CHAR_TYPE
    (23) data_type -> . array_type
    (24) data_type -> . object_type_literal
    (32) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (33) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (34) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (35) array_type -> . ANY LBRACKET RBRACKET
    (40) object_type_literal -> . LBRACE property_list RBRACE
    (41) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 74
    NUMBER_TYPE     shift and go to state 75
    BOOLEAN_TYPE    shift and go to state 76
    CHAR_TYPE       shift and go to state 77
    ANY             shift and go to state 80
    LBRACE          shift and go to state 81

    data_type                      shift and go to state 110
    array_type                     shift and go to state 78
    object_type_literal            shift and go to state 79

state 64

    (15) assignment -> VAR IDENTIFIER EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 111
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 65

    (16) assignment -> VAR IDENTIFIER COLON . data_type EQUALS value
    (17) assignment -> VAR IDENTIFIER COLON . data_type
    (19) data_type -> . STRING_TYPE
    (20) data_type -> . NUMBER_TYPE
    (21) data_type -> . BOOLEAN_TYPE
    (22) data_type -> . CHAR_TYPE
    (23) data_type -> . array_type
    (24) data_type -> . object_type_literal
    (32) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (33) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (34) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (35) array_type -> . ANY LBRACKET RBRACKET
    (40) object_type_literal -> . LBRACE property_list RBRACE
    (41) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 74
    NUMBER_TYPE     shift and go to state 75
    BOOLEAN_TYPE    shift and go to state 76
    CHAR_TYPE       shift and go to state 77
    ANY             shift and go to state 80
    LBRACE          shift and go to state 81

    data_type                      shift and go to state 112
    array_type                     shift and go to state 78
    object_type_literal            shift and go to state 79

state 66

    (101) if_statement -> IF LPAREN logical_expression . RPAREN statement_block
    (102) if_statement -> IF LPAREN logical_expression . RPAREN statement_block ELSE statement_block
    (63) logical_expression -> logical_expression . AND logical_term
    (64) logical_expression -> logical_expression . OR logical_term

    RPAREN          shift and go to state 113
    AND             shift and go to state 90
    OR              shift and go to state 91


state 67

    (69) logical_factor -> IDENTIFIER .
    (61) atom -> IDENTIFIER .

  ! reduce/reduce conflict for RPAREN resolved using rule 61 (atom -> IDENTIFIER .)
    AND             reduce using rule 69 (logical_factor -> IDENTIFIER .)
    OR              reduce using rule 69 (logical_factor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 69 (logical_factor -> IDENTIFIER .)
    LET             reduce using rule 69 (logical_factor -> IDENTIFIER .)
    CONST           reduce using rule 69 (logical_factor -> IDENTIFIER .)
    VAR             reduce using rule 69 (logical_factor -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 69 (logical_factor -> IDENTIFIER .)
    FUNCTION        reduce using rule 69 (logical_factor -> IDENTIFIER .)
    RBRACE          reduce using rule 69 (logical_factor -> IDENTIFIER .)
    COMMA           reduce using rule 69 (logical_factor -> IDENTIFIER .)
    RBRACKET        reduce using rule 69 (logical_factor -> IDENTIFIER .)
    POWER           reduce using rule 61 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 61 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (atom -> IDENTIFIER .)
    MODULE          reduce using rule 61 (atom -> IDENTIFIER .)
    EQEQ            reduce using rule 61 (atom -> IDENTIFIER .)
    NOTEQ           reduce using rule 61 (atom -> IDENTIFIER .)
    GT              reduce using rule 61 (atom -> IDENTIFIER .)
    LT              reduce using rule 61 (atom -> IDENTIFIER .)
    GE              reduce using rule 61 (atom -> IDENTIFIER .)
    LE              reduce using rule 61 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 61 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 61 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (atom -> IDENTIFIER .)

  ! RPAREN          [ reduce using rule 69 (logical_factor -> IDENTIFIER .) ]


state 68

    (73) comparison_expression -> arithmetic_expression . EQEQ arithmetic_expression
    (74) comparison_expression -> arithmetic_expression . NOTEQ arithmetic_expression
    (75) comparison_expression -> arithmetic_expression . GT arithmetic_expression
    (76) comparison_expression -> arithmetic_expression . LT arithmetic_expression
    (77) comparison_expression -> arithmetic_expression . GE arithmetic_expression
    (78) comparison_expression -> arithmetic_expression . LE arithmetic_expression
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    EQEQ            shift and go to state 84
    NOTEQ           shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    GE              shift and go to state 88
    LE              shift and go to state 89
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 69

    (94) function_def -> FUNCTION IDENTIFIER LPAREN . RPAREN statement_block
    (95) function_def -> FUNCTION IDENTIFIER LPAREN . param_list RPAREN statement_block
    (96) param_list -> . IDENTIFIER
    (97) param_list -> . IDENTIFIER COMMA param_list

    RPAREN          shift and go to state 115
    IDENTIFIER      shift and go to state 114

    param_list                     shift and go to state 116

state 70

    (98) return_statement -> RETURN expression SEMICOLON .

    LET             reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    CONST           reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    VAR             reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    FUNCTION        reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    CLASS           reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 98 (return_statement -> RETURN expression SEMICOLON .)


state 71

    (85) class_declaration -> CLASS IDENTIFIER LBRACE . class_body RBRACE
    (86) class_body -> . class_member_list
    (87) class_body -> . empty
    (88) class_member_list -> . class_member
    (89) class_member_list -> . class_member class_member_list
    (93) empty -> .
    (90) class_member -> . assignment
    (91) class_member -> . function_def
    (92) class_member -> . property
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (44) property -> . IDENTIFIER COLON data_type

    RBRACE          reduce using rule 93 (empty -> .)
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 117
    FUNCTION        shift and go to state 15

    class_body                     shift and go to state 118
    class_member_list              shift and go to state 119
    empty                          shift and go to state 120
    class_member                   shift and go to state 121
    assignment                     shift and go to state 122
    function_def                   shift and go to state 123
    property                       shift and go to state 124

state 72

    (10) assignment -> LET IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)
    LET             reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)
    CONST           reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)
    VAR             reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)
    IDENTIFIER      reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)
    FUNCTION        reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)
    RBRACE          reduce using rule 10 (assignment -> LET IDENTIFIER EQUALS value .)


state 73

    (11) assignment -> LET IDENTIFIER COLON data_type . EQUALS value
    (12) assignment -> LET IDENTIFIER COLON data_type .

    EQUALS          shift and go to state 125
    SEMICOLON       reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)
    LET             reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)
    CONST           reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)
    VAR             reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)
    IDENTIFIER      reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)
    FUNCTION        reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)
    RBRACE          reduce using rule 12 (assignment -> LET IDENTIFIER COLON data_type .)


state 74

    (19) data_type -> STRING_TYPE .
    (33) array_type -> STRING_TYPE . LBRACKET RBRACKET

    EQUALS          reduce using rule 19 (data_type -> STRING_TYPE .)
    SEMICOLON       reduce using rule 19 (data_type -> STRING_TYPE .)
    LET             reduce using rule 19 (data_type -> STRING_TYPE .)
    CONST           reduce using rule 19 (data_type -> STRING_TYPE .)
    VAR             reduce using rule 19 (data_type -> STRING_TYPE .)
    IDENTIFIER      reduce using rule 19 (data_type -> STRING_TYPE .)
    FUNCTION        reduce using rule 19 (data_type -> STRING_TYPE .)
    RBRACE          reduce using rule 19 (data_type -> STRING_TYPE .)
    LBRACKET        shift and go to state 126


state 75

    (20) data_type -> NUMBER_TYPE .
    (32) array_type -> NUMBER_TYPE . LBRACKET RBRACKET

    EQUALS          reduce using rule 20 (data_type -> NUMBER_TYPE .)
    SEMICOLON       reduce using rule 20 (data_type -> NUMBER_TYPE .)
    LET             reduce using rule 20 (data_type -> NUMBER_TYPE .)
    CONST           reduce using rule 20 (data_type -> NUMBER_TYPE .)
    VAR             reduce using rule 20 (data_type -> NUMBER_TYPE .)
    IDENTIFIER      reduce using rule 20 (data_type -> NUMBER_TYPE .)
    FUNCTION        reduce using rule 20 (data_type -> NUMBER_TYPE .)
    RBRACE          reduce using rule 20 (data_type -> NUMBER_TYPE .)
    LBRACKET        shift and go to state 127


state 76

    (21) data_type -> BOOLEAN_TYPE .
    (34) array_type -> BOOLEAN_TYPE . LBRACKET RBRACKET

    EQUALS          reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    SEMICOLON       reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    LET             reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    CONST           reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    VAR             reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    IDENTIFIER      reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    FUNCTION        reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    RBRACE          reduce using rule 21 (data_type -> BOOLEAN_TYPE .)
    LBRACKET        shift and go to state 128


state 77

    (22) data_type -> CHAR_TYPE .

    EQUALS          reduce using rule 22 (data_type -> CHAR_TYPE .)
    SEMICOLON       reduce using rule 22 (data_type -> CHAR_TYPE .)
    LET             reduce using rule 22 (data_type -> CHAR_TYPE .)
    CONST           reduce using rule 22 (data_type -> CHAR_TYPE .)
    VAR             reduce using rule 22 (data_type -> CHAR_TYPE .)
    IDENTIFIER      reduce using rule 22 (data_type -> CHAR_TYPE .)
    FUNCTION        reduce using rule 22 (data_type -> CHAR_TYPE .)
    RBRACE          reduce using rule 22 (data_type -> CHAR_TYPE .)


state 78

    (23) data_type -> array_type .

    EQUALS          reduce using rule 23 (data_type -> array_type .)
    SEMICOLON       reduce using rule 23 (data_type -> array_type .)
    LET             reduce using rule 23 (data_type -> array_type .)
    CONST           reduce using rule 23 (data_type -> array_type .)
    VAR             reduce using rule 23 (data_type -> array_type .)
    IDENTIFIER      reduce using rule 23 (data_type -> array_type .)
    FUNCTION        reduce using rule 23 (data_type -> array_type .)
    RBRACE          reduce using rule 23 (data_type -> array_type .)


state 79

    (24) data_type -> object_type_literal .

    EQUALS          reduce using rule 24 (data_type -> object_type_literal .)
    SEMICOLON       reduce using rule 24 (data_type -> object_type_literal .)
    LET             reduce using rule 24 (data_type -> object_type_literal .)
    CONST           reduce using rule 24 (data_type -> object_type_literal .)
    VAR             reduce using rule 24 (data_type -> object_type_literal .)
    IDENTIFIER      reduce using rule 24 (data_type -> object_type_literal .)
    FUNCTION        reduce using rule 24 (data_type -> object_type_literal .)
    RBRACE          reduce using rule 24 (data_type -> object_type_literal .)


state 80

    (35) array_type -> ANY . LBRACKET RBRACKET

    LBRACKET        shift and go to state 129


state 81

    (40) object_type_literal -> LBRACE . property_list RBRACE
    (41) object_type_literal -> LBRACE . RBRACE
    (49) property_list -> . property
    (50) property_list -> . property SEMICOLON property_list
    (44) property -> . IDENTIFIER COLON data_type

    RBRACE          shift and go to state 131
    IDENTIFIER      shift and go to state 133

    property_list                  shift and go to state 130
    property                       shift and go to state 132

state 82

    (51) arithmetic_expression -> arithmetic_expression PLUS . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    term                           shift and go to state 134
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 83

    (52) arithmetic_expression -> arithmetic_expression MINUS . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    term                           shift and go to state 137
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 84

    (73) comparison_expression -> arithmetic_expression EQEQ . arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 138
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 85

    (74) comparison_expression -> arithmetic_expression NOTEQ . arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 139
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 86

    (75) comparison_expression -> arithmetic_expression GT . arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 140
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 87

    (76) comparison_expression -> arithmetic_expression LT . arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 141
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 88

    (77) comparison_expression -> arithmetic_expression GE . arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 142
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 89

    (78) comparison_expression -> arithmetic_expression LE . arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 143
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 90

    (63) logical_expression -> logical_expression AND . logical_term
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 51
    IDENTIFIER      shift and go to state 67
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    logical_term                   shift and go to state 144
    logical_factor                 shift and go to state 52
    comparison_expression          shift and go to state 54
    arithmetic_expression          shift and go to state 68
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 91

    (64) logical_expression -> logical_expression OR . logical_term
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 51
    IDENTIFIER      shift and go to state 67
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    logical_term                   shift and go to state 145
    logical_factor                 shift and go to state 52
    comparison_expression          shift and go to state 54
    arithmetic_expression          shift and go to state 68
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 92

    (36) array -> LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 36 (array -> LBRACKET RBRACKET .)
    LET             reduce using rule 36 (array -> LBRACKET RBRACKET .)
    CONST           reduce using rule 36 (array -> LBRACKET RBRACKET .)
    VAR             reduce using rule 36 (array -> LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 36 (array -> LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 36 (array -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 36 (array -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 36 (array -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 36 (array -> LBRACKET RBRACKET .)


state 93

    (37) array -> LBRACKET element_list . RBRACKET

    RBRACKET        shift and go to state 146


state 94

    (38) element_list -> value .
    (39) element_list -> value . COMMA element_list

    RBRACKET        reduce using rule 38 (element_list -> value .)
    COMMA           shift and go to state 147


state 95

    (42) object_literal -> LBRACE property_assignment_list . RBRACE

    RBRACE          shift and go to state 148


state 96

    (43) object_literal -> LBRACE RBRACE .

    SEMICOLON       reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    LET             reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    CONST           reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    VAR             reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    RBRACE          reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    COMMA           reduce using rule 43 (object_literal -> LBRACE RBRACE .)
    RBRACKET        reduce using rule 43 (object_literal -> LBRACE RBRACE .)


state 97

    (45) property_assignment_list -> property_assignment .
    (46) property_assignment_list -> property_assignment . COMMA property_assignment_list

    RBRACE          reduce using rule 45 (property_assignment_list -> property_assignment .)
    COMMA           shift and go to state 149


state 98

    (47) property_assignment -> IDENTIFIER . COLON value

    COLON           shift and go to state 150


state 99

    (48) property_assignment -> STRING . COLON value

    COLON           shift and go to state 151


state 100

    (54) term -> term TIMES . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    factor                         shift and go to state 152
    atom                           shift and go to state 53

state 101

    (55) term -> term DIVIDE . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    factor                         shift and go to state 153
    atom                           shift and go to state 53

state 102

    (56) term -> term MODULE . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    factor                         shift and go to state 154
    atom                           shift and go to state 53

state 103

    (72) logical_factor -> LPAREN logical_expression . RPAREN
    (63) logical_expression -> logical_expression . AND logical_term
    (64) logical_expression -> logical_expression . OR logical_term

    RPAREN          shift and go to state 155
    AND             shift and go to state 90
    OR              shift and go to state 91


state 104

    (62) atom -> LPAREN arithmetic_expression . RPAREN
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term
    (73) comparison_expression -> arithmetic_expression . EQEQ arithmetic_expression
    (74) comparison_expression -> arithmetic_expression . NOTEQ arithmetic_expression
    (75) comparison_expression -> arithmetic_expression . GT arithmetic_expression
    (76) comparison_expression -> arithmetic_expression . LT arithmetic_expression
    (77) comparison_expression -> arithmetic_expression . GE arithmetic_expression
    (78) comparison_expression -> arithmetic_expression . LE arithmetic_expression

    RPAREN          shift and go to state 156
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83
    EQEQ            shift and go to state 84
    NOTEQ           shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    GE              shift and go to state 88
    LE              shift and go to state 89


state 105

    (66) logical_term -> NOT logical_factor .

    AND             reduce using rule 66 (logical_term -> NOT logical_factor .)
    OR              reduce using rule 66 (logical_term -> NOT logical_factor .)
    SEMICOLON       reduce using rule 66 (logical_term -> NOT logical_factor .)
    LET             reduce using rule 66 (logical_term -> NOT logical_factor .)
    CONST           reduce using rule 66 (logical_term -> NOT logical_factor .)
    VAR             reduce using rule 66 (logical_term -> NOT logical_factor .)
    IDENTIFIER      reduce using rule 66 (logical_term -> NOT logical_factor .)
    FUNCTION        reduce using rule 66 (logical_term -> NOT logical_factor .)
    RBRACE          reduce using rule 66 (logical_term -> NOT logical_factor .)
    RPAREN          reduce using rule 66 (logical_term -> NOT logical_factor .)
    COMMA           reduce using rule 66 (logical_term -> NOT logical_factor .)
    RBRACKET        reduce using rule 66 (logical_term -> NOT logical_factor .)


state 106

    (58) factor -> atom POWER . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    atom                           shift and go to state 53
    factor                         shift and go to state 157

state 107

    (82) expression -> IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    DOT             reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    LET             reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    CONST           reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    VAR             reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    IDENTIFIER      reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    FUNCTION        reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 82 (expression -> IDENTIFIER LPAREN argument_list RPAREN .)


state 108

    (84) argument_list -> expression COMMA . argument_list
    (83) argument_list -> . expression
    (84) argument_list -> . expression COMMA argument_list
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 31

    expression                     shift and go to state 61
    argument_list                  shift and go to state 158

state 109

    (13) assignment -> CONST IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)
    LET             reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)
    CONST           reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)
    VAR             reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)
    IDENTIFIER      reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)
    FUNCTION        reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)
    RBRACE          reduce using rule 13 (assignment -> CONST IDENTIFIER EQUALS value .)


state 110

    (14) assignment -> CONST IDENTIFIER COLON data_type . EQUALS value

    EQUALS          shift and go to state 159


state 111

    (15) assignment -> VAR IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)
    LET             reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)
    CONST           reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)
    VAR             reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)
    IDENTIFIER      reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)
    FUNCTION        reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)
    RBRACE          reduce using rule 15 (assignment -> VAR IDENTIFIER EQUALS value .)


state 112

    (16) assignment -> VAR IDENTIFIER COLON data_type . EQUALS value
    (17) assignment -> VAR IDENTIFIER COLON data_type .

    EQUALS          shift and go to state 160
    SEMICOLON       reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)
    LET             reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)
    CONST           reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)
    VAR             reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)
    IDENTIFIER      reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)
    FUNCTION        reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)
    RBRACE          reduce using rule 17 (assignment -> VAR IDENTIFIER COLON data_type .)


state 113

    (101) if_statement -> IF LPAREN logical_expression RPAREN . statement_block
    (102) if_statement -> IF LPAREN logical_expression RPAREN . statement_block ELSE statement_block
    (99) statement_block -> . LBRACE statement_list RBRACE
    (100) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    LBRACE          shift and go to state 162
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    statement_block                shift and go to state 161
    statement                      shift and go to state 163
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 114

    (96) param_list -> IDENTIFIER .
    (97) param_list -> IDENTIFIER . COMMA param_list

    RPAREN          reduce using rule 96 (param_list -> IDENTIFIER .)
    COMMA           shift and go to state 164


state 115

    (94) function_def -> FUNCTION IDENTIFIER LPAREN RPAREN . statement_block
    (99) statement_block -> . LBRACE statement_list RBRACE
    (100) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    LBRACE          shift and go to state 162
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    statement_block                shift and go to state 165
    statement                      shift and go to state 163
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 116

    (95) function_def -> FUNCTION IDENTIFIER LPAREN param_list . RPAREN statement_block

    RPAREN          shift and go to state 166


state 117

    (18) assignment -> IDENTIFIER . EQUALS value
    (44) property -> IDENTIFIER . COLON data_type

    EQUALS          shift and go to state 23
    COLON           shift and go to state 167


state 118

    (85) class_declaration -> CLASS IDENTIFIER LBRACE class_body . RBRACE

    RBRACE          shift and go to state 168


state 119

    (86) class_body -> class_member_list .

    RBRACE          reduce using rule 86 (class_body -> class_member_list .)


state 120

    (87) class_body -> empty .

    RBRACE          reduce using rule 87 (class_body -> empty .)


state 121

    (88) class_member_list -> class_member .
    (89) class_member_list -> class_member . class_member_list
    (88) class_member_list -> . class_member
    (89) class_member_list -> . class_member class_member_list
    (90) class_member -> . assignment
    (91) class_member -> . function_def
    (92) class_member -> . property
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (44) property -> . IDENTIFIER COLON data_type

    RBRACE          reduce using rule 88 (class_member_list -> class_member .)
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 117
    FUNCTION        shift and go to state 15

    class_member                   shift and go to state 121
    class_member_list              shift and go to state 169
    assignment                     shift and go to state 122
    function_def                   shift and go to state 123
    property                       shift and go to state 124

state 122

    (90) class_member -> assignment .

    LET             reduce using rule 90 (class_member -> assignment .)
    CONST           reduce using rule 90 (class_member -> assignment .)
    VAR             reduce using rule 90 (class_member -> assignment .)
    IDENTIFIER      reduce using rule 90 (class_member -> assignment .)
    FUNCTION        reduce using rule 90 (class_member -> assignment .)
    RBRACE          reduce using rule 90 (class_member -> assignment .)


state 123

    (91) class_member -> function_def .

    LET             reduce using rule 91 (class_member -> function_def .)
    CONST           reduce using rule 91 (class_member -> function_def .)
    VAR             reduce using rule 91 (class_member -> function_def .)
    IDENTIFIER      reduce using rule 91 (class_member -> function_def .)
    FUNCTION        reduce using rule 91 (class_member -> function_def .)
    RBRACE          reduce using rule 91 (class_member -> function_def .)


state 124

    (92) class_member -> property .

    LET             reduce using rule 92 (class_member -> property .)
    CONST           reduce using rule 92 (class_member -> property .)
    VAR             reduce using rule 92 (class_member -> property .)
    IDENTIFIER      reduce using rule 92 (class_member -> property .)
    FUNCTION        reduce using rule 92 (class_member -> property .)
    RBRACE          reduce using rule 92 (class_member -> property .)


state 125

    (11) assignment -> LET IDENTIFIER COLON data_type EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 170
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 126

    (33) array_type -> STRING_TYPE LBRACKET . RBRACKET

    RBRACKET        shift and go to state 171


state 127

    (32) array_type -> NUMBER_TYPE LBRACKET . RBRACKET

    RBRACKET        shift and go to state 172


state 128

    (34) array_type -> BOOLEAN_TYPE LBRACKET . RBRACKET

    RBRACKET        shift and go to state 173


state 129

    (35) array_type -> ANY LBRACKET . RBRACKET

    RBRACKET        shift and go to state 174


state 130

    (40) object_type_literal -> LBRACE property_list . RBRACE

    RBRACE          shift and go to state 175


state 131

    (41) object_type_literal -> LBRACE RBRACE .

    EQUALS          reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    LET             reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    CONST           reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    VAR             reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    FUNCTION        reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)
    RBRACE          reduce using rule 41 (object_type_literal -> LBRACE RBRACE .)


state 132

    (49) property_list -> property .
    (50) property_list -> property . SEMICOLON property_list

    RBRACE          reduce using rule 49 (property_list -> property .)
    SEMICOLON       shift and go to state 176


state 133

    (44) property -> IDENTIFIER . COLON data_type

    COLON           shift and go to state 167


state 134

    (51) arithmetic_expression -> arithmetic_expression PLUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor
    (56) term -> term . MODULE factor

    PLUS            reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    MINUS           reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    EQEQ            reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    NOTEQ           reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    GT              reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    LT              reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    GE              reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    LE              reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    SEMICOLON       reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    LET             reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    CONST           reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    VAR             reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    IDENTIFIER      reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    FUNCTION        reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RBRACE          reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    COMMA           reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RBRACKET        reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RPAREN          reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    AND             reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    OR              reduce using rule 51 (arithmetic_expression -> arithmetic_expression PLUS term .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102


state 135

    (61) atom -> IDENTIFIER .

    POWER           reduce using rule 61 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 61 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 61 (atom -> IDENTIFIER .)
    MODULE          reduce using rule 61 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 61 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 61 (atom -> IDENTIFIER .)
    EQEQ            reduce using rule 61 (atom -> IDENTIFIER .)
    NOTEQ           reduce using rule 61 (atom -> IDENTIFIER .)
    GT              reduce using rule 61 (atom -> IDENTIFIER .)
    LT              reduce using rule 61 (atom -> IDENTIFIER .)
    GE              reduce using rule 61 (atom -> IDENTIFIER .)
    LE              reduce using rule 61 (atom -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (atom -> IDENTIFIER .)
    LET             reduce using rule 61 (atom -> IDENTIFIER .)
    CONST           reduce using rule 61 (atom -> IDENTIFIER .)
    VAR             reduce using rule 61 (atom -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 61 (atom -> IDENTIFIER .)
    FUNCTION        reduce using rule 61 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 61 (atom -> IDENTIFIER .)
    COMMA           reduce using rule 61 (atom -> IDENTIFIER .)
    RBRACKET        reduce using rule 61 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 61 (atom -> IDENTIFIER .)
    AND             reduce using rule 61 (atom -> IDENTIFIER .)
    OR              reduce using rule 61 (atom -> IDENTIFIER .)


state 136

    (62) atom -> LPAREN . arithmetic_expression RPAREN
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 57
    IDENTIFIER      shift and go to state 135
    LPAREN          shift and go to state 136

    arithmetic_expression          shift and go to state 177
    term                           shift and go to state 47
    factor                         shift and go to state 50
    atom                           shift and go to state 53

state 137

    (52) arithmetic_expression -> arithmetic_expression MINUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor
    (56) term -> term . MODULE factor

    PLUS            reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    MINUS           reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    EQEQ            reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    NOTEQ           reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    GT              reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    LT              reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    GE              reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    LE              reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    SEMICOLON       reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    LET             reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    CONST           reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    VAR             reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    IDENTIFIER      reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    FUNCTION        reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RBRACE          reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    COMMA           reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RBRACKET        reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RPAREN          reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    AND             reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    OR              reduce using rule 52 (arithmetic_expression -> arithmetic_expression MINUS term .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101
    MODULE          shift and go to state 102


state 138

    (73) comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    OR              reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    SEMICOLON       reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    LET             reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    CONST           reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    VAR             reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    IDENTIFIER      reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    FUNCTION        reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    RBRACE          reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    RPAREN          reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    COMMA           reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    RBRACKET        reduce using rule 73 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 139

    (74) comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    OR              reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    SEMICOLON       reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    LET             reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    CONST           reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    VAR             reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    IDENTIFIER      reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    FUNCTION        reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    RBRACE          reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    RPAREN          reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    COMMA           reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    RBRACKET        reduce using rule 74 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 140

    (75) comparison_expression -> arithmetic_expression GT arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    OR              reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    SEMICOLON       reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    LET             reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    CONST           reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    VAR             reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    IDENTIFIER      reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    FUNCTION        reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    RBRACE          reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    RPAREN          reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    COMMA           reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    RBRACKET        reduce using rule 75 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 141

    (76) comparison_expression -> arithmetic_expression LT arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    OR              reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    SEMICOLON       reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    LET             reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    CONST           reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    VAR             reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    IDENTIFIER      reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    FUNCTION        reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    RBRACE          reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    RPAREN          reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    COMMA           reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    RBRACKET        reduce using rule 76 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 142

    (77) comparison_expression -> arithmetic_expression GE arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    OR              reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    SEMICOLON       reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    LET             reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    CONST           reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    VAR             reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    IDENTIFIER      reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    FUNCTION        reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    RBRACE          reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    RPAREN          reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    COMMA           reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    RBRACKET        reduce using rule 77 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 143

    (78) comparison_expression -> arithmetic_expression LE arithmetic_expression .
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    OR              reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    SEMICOLON       reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    LET             reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    CONST           reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    VAR             reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    IDENTIFIER      reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    FUNCTION        reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    RBRACE          reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    RPAREN          reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    COMMA           reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    RBRACKET        reduce using rule 78 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 144

    (63) logical_expression -> logical_expression AND logical_term .

    AND             reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    OR              reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    SEMICOLON       reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    LET             reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    CONST           reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    VAR             reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    IDENTIFIER      reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    FUNCTION        reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    RBRACE          reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    RPAREN          reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    COMMA           reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)
    RBRACKET        reduce using rule 63 (logical_expression -> logical_expression AND logical_term .)


state 145

    (64) logical_expression -> logical_expression OR logical_term .

    AND             reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    OR              reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    SEMICOLON       reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    LET             reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    CONST           reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    VAR             reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    IDENTIFIER      reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    FUNCTION        reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    RBRACE          reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    RPAREN          reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    COMMA           reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)
    RBRACKET        reduce using rule 64 (logical_expression -> logical_expression OR logical_term .)


state 146

    (37) array -> LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    LET             reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    CONST           reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    VAR             reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    IDENTIFIER      reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    FUNCTION        reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 37 (array -> LBRACKET element_list RBRACKET .)


state 147

    (39) element_list -> value COMMA . element_list
    (38) element_list -> . value
    (39) element_list -> . value COMMA element_list
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 94
    element_list                   shift and go to state 178
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 148

    (42) object_literal -> LBRACE property_assignment_list RBRACE .

    SEMICOLON       reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    LET             reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    CONST           reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    VAR             reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    IDENTIFIER      reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    FUNCTION        reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    RBRACE          reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    COMMA           reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)
    RBRACKET        reduce using rule 42 (object_literal -> LBRACE property_assignment_list RBRACE .)


state 149

    (46) property_assignment_list -> property_assignment COMMA . property_assignment_list
    (45) property_assignment_list -> . property_assignment
    (46) property_assignment_list -> . property_assignment COMMA property_assignment_list
    (47) property_assignment -> . IDENTIFIER COLON value
    (48) property_assignment -> . STRING COLON value

    IDENTIFIER      shift and go to state 98
    STRING          shift and go to state 99

    property_assignment            shift and go to state 97
    property_assignment_list       shift and go to state 179

state 150

    (47) property_assignment -> IDENTIFIER COLON . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 180
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 151

    (48) property_assignment -> STRING COLON . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 181
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 152

    (54) term -> term TIMES factor .

    TIMES           reduce using rule 54 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 54 (term -> term TIMES factor .)
    MODULE          reduce using rule 54 (term -> term TIMES factor .)
    PLUS            reduce using rule 54 (term -> term TIMES factor .)
    MINUS           reduce using rule 54 (term -> term TIMES factor .)
    EQEQ            reduce using rule 54 (term -> term TIMES factor .)
    NOTEQ           reduce using rule 54 (term -> term TIMES factor .)
    GT              reduce using rule 54 (term -> term TIMES factor .)
    LT              reduce using rule 54 (term -> term TIMES factor .)
    GE              reduce using rule 54 (term -> term TIMES factor .)
    LE              reduce using rule 54 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 54 (term -> term TIMES factor .)
    LET             reduce using rule 54 (term -> term TIMES factor .)
    CONST           reduce using rule 54 (term -> term TIMES factor .)
    VAR             reduce using rule 54 (term -> term TIMES factor .)
    IDENTIFIER      reduce using rule 54 (term -> term TIMES factor .)
    FUNCTION        reduce using rule 54 (term -> term TIMES factor .)
    RBRACE          reduce using rule 54 (term -> term TIMES factor .)
    COMMA           reduce using rule 54 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 54 (term -> term TIMES factor .)
    RPAREN          reduce using rule 54 (term -> term TIMES factor .)
    AND             reduce using rule 54 (term -> term TIMES factor .)
    OR              reduce using rule 54 (term -> term TIMES factor .)


state 153

    (55) term -> term DIVIDE factor .

    TIMES           reduce using rule 55 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 55 (term -> term DIVIDE factor .)
    MODULE          reduce using rule 55 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 55 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 55 (term -> term DIVIDE factor .)
    EQEQ            reduce using rule 55 (term -> term DIVIDE factor .)
    NOTEQ           reduce using rule 55 (term -> term DIVIDE factor .)
    GT              reduce using rule 55 (term -> term DIVIDE factor .)
    LT              reduce using rule 55 (term -> term DIVIDE factor .)
    GE              reduce using rule 55 (term -> term DIVIDE factor .)
    LE              reduce using rule 55 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 55 (term -> term DIVIDE factor .)
    LET             reduce using rule 55 (term -> term DIVIDE factor .)
    CONST           reduce using rule 55 (term -> term DIVIDE factor .)
    VAR             reduce using rule 55 (term -> term DIVIDE factor .)
    IDENTIFIER      reduce using rule 55 (term -> term DIVIDE factor .)
    FUNCTION        reduce using rule 55 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 55 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 55 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 55 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 55 (term -> term DIVIDE factor .)
    AND             reduce using rule 55 (term -> term DIVIDE factor .)
    OR              reduce using rule 55 (term -> term DIVIDE factor .)


state 154

    (56) term -> term MODULE factor .

    TIMES           reduce using rule 56 (term -> term MODULE factor .)
    DIVIDE          reduce using rule 56 (term -> term MODULE factor .)
    MODULE          reduce using rule 56 (term -> term MODULE factor .)
    PLUS            reduce using rule 56 (term -> term MODULE factor .)
    MINUS           reduce using rule 56 (term -> term MODULE factor .)
    EQEQ            reduce using rule 56 (term -> term MODULE factor .)
    NOTEQ           reduce using rule 56 (term -> term MODULE factor .)
    GT              reduce using rule 56 (term -> term MODULE factor .)
    LT              reduce using rule 56 (term -> term MODULE factor .)
    GE              reduce using rule 56 (term -> term MODULE factor .)
    LE              reduce using rule 56 (term -> term MODULE factor .)
    SEMICOLON       reduce using rule 56 (term -> term MODULE factor .)
    LET             reduce using rule 56 (term -> term MODULE factor .)
    CONST           reduce using rule 56 (term -> term MODULE factor .)
    VAR             reduce using rule 56 (term -> term MODULE factor .)
    IDENTIFIER      reduce using rule 56 (term -> term MODULE factor .)
    FUNCTION        reduce using rule 56 (term -> term MODULE factor .)
    RBRACE          reduce using rule 56 (term -> term MODULE factor .)
    COMMA           reduce using rule 56 (term -> term MODULE factor .)
    RBRACKET        reduce using rule 56 (term -> term MODULE factor .)
    RPAREN          reduce using rule 56 (term -> term MODULE factor .)
    AND             reduce using rule 56 (term -> term MODULE factor .)
    OR              reduce using rule 56 (term -> term MODULE factor .)


state 155

    (72) logical_factor -> LPAREN logical_expression RPAREN .

    AND             reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    OR              reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    SEMICOLON       reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    LET             reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    CONST           reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    VAR             reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    IDENTIFIER      reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    FUNCTION        reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    RBRACE          reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    RPAREN          reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    COMMA           reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)
    RBRACKET        reduce using rule 72 (logical_factor -> LPAREN logical_expression RPAREN .)


state 156

    (62) atom -> LPAREN arithmetic_expression RPAREN .

    POWER           reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    TIMES           reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    DIVIDE          reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    MODULE          reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    PLUS            reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    MINUS           reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    EQEQ            reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    NOTEQ           reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    GT              reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    LT              reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    GE              reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    LE              reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    SEMICOLON       reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    LET             reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    CONST           reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    VAR             reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    IDENTIFIER      reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    FUNCTION        reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    RBRACE          reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    COMMA           reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    RBRACKET        reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    RPAREN          reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    AND             reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)
    OR              reduce using rule 62 (atom -> LPAREN arithmetic_expression RPAREN .)


state 157

    (58) factor -> atom POWER factor .

    TIMES           reduce using rule 58 (factor -> atom POWER factor .)
    DIVIDE          reduce using rule 58 (factor -> atom POWER factor .)
    MODULE          reduce using rule 58 (factor -> atom POWER factor .)
    PLUS            reduce using rule 58 (factor -> atom POWER factor .)
    MINUS           reduce using rule 58 (factor -> atom POWER factor .)
    EQEQ            reduce using rule 58 (factor -> atom POWER factor .)
    NOTEQ           reduce using rule 58 (factor -> atom POWER factor .)
    GT              reduce using rule 58 (factor -> atom POWER factor .)
    LT              reduce using rule 58 (factor -> atom POWER factor .)
    GE              reduce using rule 58 (factor -> atom POWER factor .)
    LE              reduce using rule 58 (factor -> atom POWER factor .)
    SEMICOLON       reduce using rule 58 (factor -> atom POWER factor .)
    LET             reduce using rule 58 (factor -> atom POWER factor .)
    CONST           reduce using rule 58 (factor -> atom POWER factor .)
    VAR             reduce using rule 58 (factor -> atom POWER factor .)
    IDENTIFIER      reduce using rule 58 (factor -> atom POWER factor .)
    FUNCTION        reduce using rule 58 (factor -> atom POWER factor .)
    RBRACE          reduce using rule 58 (factor -> atom POWER factor .)
    COMMA           reduce using rule 58 (factor -> atom POWER factor .)
    RBRACKET        reduce using rule 58 (factor -> atom POWER factor .)
    RPAREN          reduce using rule 58 (factor -> atom POWER factor .)
    AND             reduce using rule 58 (factor -> atom POWER factor .)
    OR              reduce using rule 58 (factor -> atom POWER factor .)


state 158

    (84) argument_list -> expression COMMA argument_list .

    RPAREN          reduce using rule 84 (argument_list -> expression COMMA argument_list .)


state 159

    (14) assignment -> CONST IDENTIFIER COLON data_type EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 182
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 160

    (16) assignment -> VAR IDENTIFIER COLON data_type EQUALS . value
    (25) value -> . STRING
    (26) value -> . CHARACTER
    (27) value -> . array
    (28) value -> . object_literal
    (29) value -> . arithmetic_expression
    (30) value -> . logical_expression
    (31) value -> . expression
    (36) array -> . LBRACKET RBRACKET
    (37) array -> . LBRACKET element_list RBRACKET
    (42) object_literal -> . LBRACE property_assignment_list RBRACE
    (43) object_literal -> . LBRACE RBRACE
    (51) arithmetic_expression -> . arithmetic_expression PLUS term
    (52) arithmetic_expression -> . arithmetic_expression MINUS term
    (53) arithmetic_expression -> . term
    (63) logical_expression -> . logical_expression AND logical_term
    (64) logical_expression -> . logical_expression OR logical_term
    (65) logical_expression -> . logical_term
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) term -> . term MODULE factor
    (57) term -> . factor
    (66) logical_term -> . NOT logical_factor
    (67) logical_term -> . logical_factor
    (58) factor -> . atom POWER factor
    (59) factor -> . atom
    (68) logical_factor -> . comparison_expression
    (69) logical_factor -> . IDENTIFIER
    (70) logical_factor -> . TRUE
    (71) logical_factor -> . FALSE
    (72) logical_factor -> . LPAREN logical_expression RPAREN
    (60) atom -> . NUMBER
    (61) atom -> . IDENTIFIER
    (62) atom -> . LPAREN arithmetic_expression RPAREN
    (73) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (74) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (75) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 38
    CHARACTER       shift and go to state 39
    LBRACKET        shift and go to state 45
    LBRACE          shift and go to state 46
    IDENTIFIER      shift and go to state 36
    NOT             shift and go to state 51
    TRUE            shift and go to state 55
    FALSE           shift and go to state 56
    LPAREN          shift and go to state 49
    NUMBER          shift and go to state 57

    value                          shift and go to state 183
    array                          shift and go to state 40
    object_literal                 shift and go to state 41
    arithmetic_expression          shift and go to state 42
    logical_expression             shift and go to state 43
    expression                     shift and go to state 44
    term                           shift and go to state 47
    logical_term                   shift and go to state 48
    factor                         shift and go to state 50
    logical_factor                 shift and go to state 52
    atom                           shift and go to state 53
    comparison_expression          shift and go to state 54

state 161

    (101) if_statement -> IF LPAREN logical_expression RPAREN statement_block .
    (102) if_statement -> IF LPAREN logical_expression RPAREN statement_block . ELSE statement_block

  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    CONST           reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    VAR             reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    IDENTIFIER      reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    IF              reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    FUNCTION        reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    RETURN          reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    CLASS           reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    $end            reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    RBRACE          reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    ELSE            shift and go to state 184

  ! ELSE            [ reduce using rule 101 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .) ]


state 162

    (99) statement_block -> LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement statement_list
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    statement_list                 shift and go to state 185
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 163

    (100) statement_block -> statement .

    ELSE            reduce using rule 100 (statement_block -> statement .)
    LET             reduce using rule 100 (statement_block -> statement .)
    CONST           reduce using rule 100 (statement_block -> statement .)
    VAR             reduce using rule 100 (statement_block -> statement .)
    IDENTIFIER      reduce using rule 100 (statement_block -> statement .)
    IF              reduce using rule 100 (statement_block -> statement .)
    FUNCTION        reduce using rule 100 (statement_block -> statement .)
    RETURN          reduce using rule 100 (statement_block -> statement .)
    CLASS           reduce using rule 100 (statement_block -> statement .)
    $end            reduce using rule 100 (statement_block -> statement .)
    RBRACE          reduce using rule 100 (statement_block -> statement .)


state 164

    (97) param_list -> IDENTIFIER COMMA . param_list
    (96) param_list -> . IDENTIFIER
    (97) param_list -> . IDENTIFIER COMMA param_list

    IDENTIFIER      shift and go to state 114

    param_list                     shift and go to state 186

state 165

    (94) function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .

    LET             reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    CONST           reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    VAR             reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    IDENTIFIER      reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    IF              reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    FUNCTION        reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    RETURN          reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    CLASS           reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    $end            reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    RBRACE          reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    ELSE            reduce using rule 94 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)


state 166

    (95) function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN . statement_block
    (99) statement_block -> . LBRACE statement_list RBRACE
    (100) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    LBRACE          shift and go to state 162
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    statement_block                shift and go to state 187
    statement                      shift and go to state 163
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 167

    (44) property -> IDENTIFIER COLON . data_type
    (19) data_type -> . STRING_TYPE
    (20) data_type -> . NUMBER_TYPE
    (21) data_type -> . BOOLEAN_TYPE
    (22) data_type -> . CHAR_TYPE
    (23) data_type -> . array_type
    (24) data_type -> . object_type_literal
    (32) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (33) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (34) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (35) array_type -> . ANY LBRACKET RBRACKET
    (40) object_type_literal -> . LBRACE property_list RBRACE
    (41) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 74
    NUMBER_TYPE     shift and go to state 75
    BOOLEAN_TYPE    shift and go to state 76
    CHAR_TYPE       shift and go to state 77
    ANY             shift and go to state 80
    LBRACE          shift and go to state 81

    data_type                      shift and go to state 188
    array_type                     shift and go to state 78
    object_type_literal            shift and go to state 79

state 168

    (85) class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .

    LET             reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CONST           reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    VAR             reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    IDENTIFIER      reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    IF              reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FUNCTION        reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    RETURN          reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CLASS           reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    $end            reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    ELSE            reduce using rule 85 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)


state 169

    (89) class_member_list -> class_member class_member_list .

    RBRACE          reduce using rule 89 (class_member_list -> class_member class_member_list .)


state 170

    (11) assignment -> LET IDENTIFIER COLON data_type EQUALS value .

    SEMICOLON       reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    LET             reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    CONST           reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    VAR             reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    IDENTIFIER      reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    FUNCTION        reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    RBRACE          reduce using rule 11 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)


state 171

    (33) array_type -> STRING_TYPE LBRACKET RBRACKET .

    EQUALS          reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    LET             reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    CONST           reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    VAR             reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 33 (array_type -> STRING_TYPE LBRACKET RBRACKET .)


state 172

    (32) array_type -> NUMBER_TYPE LBRACKET RBRACKET .

    EQUALS          reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    LET             reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    CONST           reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    VAR             reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 32 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)


state 173

    (34) array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .

    EQUALS          reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    LET             reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    CONST           reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    VAR             reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 34 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)


state 174

    (35) array_type -> ANY LBRACKET RBRACKET .

    EQUALS          reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    LET             reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    CONST           reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    VAR             reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    FUNCTION        reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)
    RBRACE          reduce using rule 35 (array_type -> ANY LBRACKET RBRACKET .)


state 175

    (40) object_type_literal -> LBRACE property_list RBRACE .

    EQUALS          reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    SEMICOLON       reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    LET             reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    CONST           reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    VAR             reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    IDENTIFIER      reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    FUNCTION        reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)
    RBRACE          reduce using rule 40 (object_type_literal -> LBRACE property_list RBRACE .)


state 176

    (50) property_list -> property SEMICOLON . property_list
    (49) property_list -> . property
    (50) property_list -> . property SEMICOLON property_list
    (44) property -> . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 133

    property                       shift and go to state 132
    property_list                  shift and go to state 189

state 177

    (62) atom -> LPAREN arithmetic_expression . RPAREN
    (51) arithmetic_expression -> arithmetic_expression . PLUS term
    (52) arithmetic_expression -> arithmetic_expression . MINUS term

    RPAREN          shift and go to state 156
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 178

    (39) element_list -> value COMMA element_list .

    RBRACKET        reduce using rule 39 (element_list -> value COMMA element_list .)


state 179

    (46) property_assignment_list -> property_assignment COMMA property_assignment_list .

    RBRACE          reduce using rule 46 (property_assignment_list -> property_assignment COMMA property_assignment_list .)


state 180

    (47) property_assignment -> IDENTIFIER COLON value .

    COMMA           reduce using rule 47 (property_assignment -> IDENTIFIER COLON value .)
    RBRACE          reduce using rule 47 (property_assignment -> IDENTIFIER COLON value .)


state 181

    (48) property_assignment -> STRING COLON value .

    COMMA           reduce using rule 48 (property_assignment -> STRING COLON value .)
    RBRACE          reduce using rule 48 (property_assignment -> STRING COLON value .)


state 182

    (14) assignment -> CONST IDENTIFIER COLON data_type EQUALS value .

    SEMICOLON       reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    LET             reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    CONST           reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    VAR             reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    IDENTIFIER      reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    FUNCTION        reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    RBRACE          reduce using rule 14 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)


state 183

    (16) assignment -> VAR IDENTIFIER COLON data_type EQUALS value .

    SEMICOLON       reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    LET             reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    CONST           reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    VAR             reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    IDENTIFIER      reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    FUNCTION        reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    RBRACE          reduce using rule 16 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)


state 184

    (102) if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE . statement_block
    (99) statement_block -> . LBRACE statement_list RBRACE
    (100) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) assignment -> . LET IDENTIFIER EQUALS value
    (11) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (12) assignment -> . LET IDENTIFIER COLON data_type
    (13) assignment -> . CONST IDENTIFIER EQUALS value
    (14) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (15) assignment -> . VAR IDENTIFIER EQUALS value
    (16) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (17) assignment -> . VAR IDENTIFIER COLON data_type
    (18) assignment -> . IDENTIFIER EQUALS value
    (79) expression -> . expression DOT IDENTIFIER
    (80) expression -> . IDENTIFIER DOT IDENTIFIER
    (81) expression -> . IDENTIFIER LPAREN RPAREN
    (82) expression -> . IDENTIFIER LPAREN argument_list RPAREN
    (101) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (102) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (94) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (95) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (98) return_statement -> . RETURN expression SEMICOLON
    (85) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE

    LBRACE          shift and go to state 162
    LET             shift and go to state 10
    CONST           shift and go to state 12
    VAR             shift and go to state 13
    IDENTIFIER      shift and go to state 11
    IF              shift and go to state 14
    FUNCTION        shift and go to state 15
    RETURN          shift and go to state 16
    CLASS           shift and go to state 17

    statement_block                shift and go to state 190
    statement                      shift and go to state 163
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9

state 185

    (99) statement_block -> LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 191


state 186

    (97) param_list -> IDENTIFIER COMMA param_list .

    RPAREN          reduce using rule 97 (param_list -> IDENTIFIER COMMA param_list .)


state 187

    (95) function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .

    LET             reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    CONST           reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    VAR             reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    IDENTIFIER      reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    IF              reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    FUNCTION        reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    RETURN          reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    CLASS           reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    $end            reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    RBRACE          reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    ELSE            reduce using rule 95 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)


state 188

    (44) property -> IDENTIFIER COLON data_type .

    LET             reduce using rule 44 (property -> IDENTIFIER COLON data_type .)
    CONST           reduce using rule 44 (property -> IDENTIFIER COLON data_type .)
    VAR             reduce using rule 44 (property -> IDENTIFIER COLON data_type .)
    IDENTIFIER      reduce using rule 44 (property -> IDENTIFIER COLON data_type .)
    FUNCTION        reduce using rule 44 (property -> IDENTIFIER COLON data_type .)
    RBRACE          reduce using rule 44 (property -> IDENTIFIER COLON data_type .)
    SEMICOLON       reduce using rule 44 (property -> IDENTIFIER COLON data_type .)


state 189

    (50) property_list -> property SEMICOLON property_list .

    RBRACE          reduce using rule 50 (property_list -> property SEMICOLON property_list .)


state 190

    (102) if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .

    LET             reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    CONST           reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    VAR             reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    IDENTIFIER      reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    IF              reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    FUNCTION        reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    RETURN          reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    CLASS           reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    $end            reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    RBRACE          reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    ELSE            reduce using rule 102 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)


state 191

    (99) statement_block -> LBRACE statement_list RBRACE .

    ELSE            reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    LET             reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    CONST           reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    VAR             reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 99 (statement_block -> LBRACE statement_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 161 resolved as shift
WARNING: reduce/reduce conflict in state 36 resolved using rule (atom -> IDENTIFIER)
WARNING: rejected rule (logical_factor -> IDENTIFIER) in state 36
WARNING: reduce/reduce conflict in state 67 resolved using rule (atom -> IDENTIFIER)
WARNING: rejected rule (logical_factor -> IDENTIFIER) in state 67
