Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    BACKTICK
    CASE
    DEFAULT
    DOLLAR
    INTERFACE
    PIPE
    PRIVATE
    PROTECTED
    PUBLIC
    QUESTION
    SWITCH
    TYPE
    TYPEOF
    VOID

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement statement_list
Rule 4     statement -> assignment SEMICOLON
Rule 5     statement -> expression SEMICOLON
Rule 6     statement -> if_statement
Rule 7     statement -> function_def
Rule 8     statement -> return_statement
Rule 9     statement -> class_declaration
Rule 10    statement -> while_statement
Rule 11    statement -> for_statement
Rule 12    statement -> break_statement
Rule 13    statement -> continue_statement
Rule 14    assignment -> LET IDENTIFIER EQUALS value
Rule 15    assignment -> LET IDENTIFIER COLON data_type EQUALS value
Rule 16    assignment -> LET IDENTIFIER COLON data_type
Rule 17    assignment -> CONST IDENTIFIER EQUALS value
Rule 18    assignment -> CONST IDENTIFIER COLON data_type EQUALS value
Rule 19    assignment -> VAR IDENTIFIER EQUALS value
Rule 20    assignment -> VAR IDENTIFIER COLON data_type EQUALS value
Rule 21    assignment -> VAR IDENTIFIER COLON data_type
Rule 22    assignment -> IDENTIFIER EQUALS value
Rule 23    assignment -> IDENTIFIER COLON value
Rule 24    data_type -> STRING_TYPE
Rule 25    data_type -> NUMBER_TYPE
Rule 26    data_type -> BOOLEAN_TYPE
Rule 27    data_type -> CHAR_TYPE
Rule 28    data_type -> array_type
Rule 29    data_type -> object_type_literal
Rule 30    value -> STRING
Rule 31    value -> CHARACTER
Rule 32    value -> array
Rule 33    value -> object_literal
Rule 34    value -> expression
Rule 35    array_type -> NUMBER_TYPE LBRACKET RBRACKET
Rule 36    array_type -> STRING_TYPE LBRACKET RBRACKET
Rule 37    array_type -> BOOLEAN_TYPE LBRACKET RBRACKET
Rule 38    array_type -> ANY LBRACKET RBRACKET
Rule 39    array -> LBRACKET RBRACKET
Rule 40    array -> LBRACKET element_list RBRACKET
Rule 41    element_list -> value
Rule 42    element_list -> value COMMA element_list
Rule 43    object_type_literal -> LBRACE property_list RBRACE
Rule 44    object_type_literal -> LBRACE RBRACE
Rule 45    object_literal -> LBRACE property_assignment_list RBRACE
Rule 46    property -> IDENTIFIER COLON data_type
Rule 47    property_assignment_list -> property_assignment
Rule 48    property_assignment_list -> property_assignment COMMA property_assignment_list
Rule 49    property_assignment -> IDENTIFIER COLON value
Rule 50    property_assignment -> STRING COLON value
Rule 51    property_list -> property
Rule 52    property_list -> property SEMICOLON property_list
Rule 53    property_list -> property COMMA property_list
Rule 54    arithmetic_expression -> arithmetic_expression PLUS term
Rule 55    arithmetic_expression -> arithmetic_expression MINUS term
Rule 56    arithmetic_expression -> term
Rule 57    term -> term TIMES factor
Rule 58    term -> term DIVIDE factor
Rule 59    term -> term MODULE factor
Rule 60    term -> factor
Rule 61    factor -> atom POWER factor
Rule 62    factor -> atom
Rule 63    atom -> NUMBER
Rule 64    atom -> IDENTIFIER
Rule 65    atom -> LPAREN arithmetic_expression RPAREN
Rule 66    logical_expression -> logical_expression AND logical_term
Rule 67    logical_expression -> logical_expression OR logical_term
Rule 68    logical_expression -> logical_term
Rule 69    logical_term -> NOT logical_factor
Rule 70    logical_term -> logical_factor
Rule 71    logical_factor -> comparison_expression
Rule 72    logical_factor -> TRUE
Rule 73    logical_factor -> FALSE
Rule 74    logical_factor -> LPAREN logical_expression RPAREN
Rule 75    comparison_expression -> arithmetic_expression EQEQ arithmetic_expression
Rule 76    comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression
Rule 77    comparison_expression -> arithmetic_expression GT arithmetic_expression
Rule 78    comparison_expression -> arithmetic_expression LT arithmetic_expression
Rule 79    comparison_expression -> arithmetic_expression GE arithmetic_expression
Rule 80    comparison_expression -> arithmetic_expression LE arithmetic_expression
Rule 81    expression -> arithmetic_expression
Rule 82    expression -> logical_expression
Rule 83    expression -> member_access
Rule 84    expression -> function_call
Rule 85    expression -> class_instantiation
Rule 86    expression -> this_access
Rule 87    member_access -> member_access DOT IDENTIFIER
Rule 88    member_access -> IDENTIFIER DOT IDENTIFIER
Rule 89    function_call -> IDENTIFIER LPAREN RPAREN
Rule 90    function_call -> IDENTIFIER LPAREN argument_list RPAREN
Rule 91    argument_list -> expression
Rule 92    argument_list -> expression COMMA argument_list
Rule 93    class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE
Rule 94    class_instantiation -> NEW IDENTIFIER LPAREN RPAREN
Rule 95    class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN
Rule 96    class_body -> class_member_list
Rule 97    class_body -> empty
Rule 98    class_member_list -> class_member
Rule 99    class_member_list -> class_member class_member_list
Rule 100   class_member -> assignment SEMICOLON
Rule 101   class_member -> class_property
Rule 102   class_member -> function_def
Rule 103   class_member -> constructor
Rule 104   empty -> <empty>
Rule 105   class_property -> IDENTIFIER COLON data_type SEMICOLON
Rule 106   class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON
Rule 107   constructor -> CONSTRUCTOR LPAREN RPAREN statement_block
Rule 108   constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block
Rule 109   assignment -> THIS DOT IDENTIFIER EQUALS value
Rule 110   this_access -> THIS DOT IDENTIFIER
Rule 111   this_access -> THIS
Rule 112   function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block
Rule 113   function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
Rule 114   param_list -> IDENTIFIER
Rule 115   param_list -> IDENTIFIER COMMA param_list
Rule 116   param_list -> IDENTIFIER COLON data_type
Rule 117   param_list -> IDENTIFIER COLON data_type COMMA param_list
Rule 118   return_statement -> RETURN expression SEMICOLON
Rule 119   statement_block -> LBRACE statement_list RBRACE
Rule 120   statement_block -> statement
Rule 121   while_statement -> WHILE LPAREN logical_expression RPAREN statement_block
Rule 122   for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
Rule 123   for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
Rule 124   if_statement -> IF LPAREN logical_expression RPAREN statement_block
Rule 125   if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
Rule 126   break_statement -> BREAK SEMICOLON
Rule 127   continue_statement -> CONTINUE SEMICOLON

Terminals, with rules where they appear

AND                  : 66
ANY                  : 38
ARROW                : 
BACKTICK             : 
BOOLEAN_TYPE         : 26 37
BREAK                : 126
CASE                 : 
CHARACTER            : 31
CHAR_TYPE            : 27
CLASS                : 93
COLON                : 15 16 18 20 21 23 46 49 50 105 106 116 117
COMMA                : 42 48 53 92 115 117
CONST                : 17 18
CONSTRUCTOR          : 107 108
CONTINUE             : 127
DEFAULT              : 
DIVIDE               : 58
DOLLAR               : 
DOT                  : 87 88 109 110
ELSE                 : 125
EQEQ                 : 75
EQUALS               : 14 15 17 18 19 20 22 106 109
FALSE                : 73
FOR                  : 122 123
FUNCTION             : 112 113
GE                   : 79
GT                   : 77
IDENTIFIER           : 14 15 16 17 18 19 20 21 22 23 46 49 64 87 88 88 89 90 93 94 95 105 106 109 110 112 113 114 115 116 117 123
IF                   : 124 125
IN                   : 123
INTERFACE            : 
LBRACE               : 43 44 45 93 119
LBRACKET             : 35 36 37 38 39 40
LE                   : 80
LET                  : 14 15 16
LPAREN               : 65 74 89 90 94 95 107 108 112 113 121 122 123 124 125
LT                   : 78
MINUS                : 55
MODULE               : 59
NEW                  : 94 95
NOT                  : 69
NOTEQ                : 76
NUMBER               : 63
NUMBER_TYPE          : 25 35
OR                   : 67
PIPE                 : 
PLUS                 : 54
POWER                : 61
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 
QUESTION             : 
RBRACE               : 43 44 45 93 119
RBRACKET             : 35 36 37 38 39 40
RETURN               : 118
RPAREN               : 65 74 89 90 94 95 107 108 112 113 121 122 123 124 125
SEMICOLON            : 4 5 52 100 105 106 118 122 122 126 127
STRING               : 30 50
STRING_TYPE          : 24 36
SWITCH               : 
THIS                 : 109 110 111
TIMES                : 57
TRUE                 : 72
TYPE                 : 
TYPEOF               : 
VAR                  : 19 20 21
VOID                 : 
WHILE                : 121
error                : 

Nonterminals, with rules where they appear

argument_list        : 90 92 95
arithmetic_expression : 54 55 65 75 75 76 76 77 77 78 78 79 79 80 80 81
array                : 32
array_type           : 28
assignment           : 4 100 122 122
atom                 : 61 62
break_statement      : 12
class_body           : 93
class_declaration    : 9
class_instantiation  : 85
class_member         : 98 99
class_member_list    : 96 99
class_property       : 101
comparison_expression : 71
constructor          : 103
continue_statement   : 13
data_type            : 15 16 18 20 21 46 105 106 116 117
element_list         : 40 42
empty                : 97
expression           : 5 34 91 92 118 123
factor               : 57 58 59 60 61
for_statement        : 11
function_call        : 84
function_def         : 7 102
if_statement         : 6
logical_expression   : 66 67 74 82 121 122 124 125
logical_factor       : 69 70
logical_term         : 66 67 68
member_access        : 83 87
object_literal       : 33
object_type_literal  : 29
param_list           : 108 113 115 117
program              : 0
property             : 51 52 53
property_assignment  : 47 48
property_assignment_list : 45 48
property_list        : 43 52 53
return_statement     : 8
statement            : 2 3 120
statement_block      : 107 108 112 113 121 122 123 124 125 125
statement_list       : 1 3 119
term                 : 54 55 56 57 58 59
this_access          : 86
value                : 14 15 17 18 19 20 22 23 41 42 49 50 106 109
while_statement      : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement statement_list
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .

    $end            reduce using rule 1 (program -> statement_list .)


state 3

    (2) statement_list -> statement .
    (3) statement_list -> statement . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement statement_list
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement .)
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    statement                      shift and go to state 3
    statement_list                 shift and go to state 45
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 4

    (4) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 46


state 5

    (5) statement -> expression . SEMICOLON

    SEMICOLON       shift and go to state 47


state 6

    (6) statement -> if_statement .

    LET             reduce using rule 6 (statement -> if_statement .)
    CONST           reduce using rule 6 (statement -> if_statement .)
    VAR             reduce using rule 6 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 6 (statement -> if_statement .)
    THIS            reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    FUNCTION        reduce using rule 6 (statement -> if_statement .)
    RETURN          reduce using rule 6 (statement -> if_statement .)
    CLASS           reduce using rule 6 (statement -> if_statement .)
    WHILE           reduce using rule 6 (statement -> if_statement .)
    FOR             reduce using rule 6 (statement -> if_statement .)
    BREAK           reduce using rule 6 (statement -> if_statement .)
    CONTINUE        reduce using rule 6 (statement -> if_statement .)
    NEW             reduce using rule 6 (statement -> if_statement .)
    NOT             reduce using rule 6 (statement -> if_statement .)
    TRUE            reduce using rule 6 (statement -> if_statement .)
    FALSE           reduce using rule 6 (statement -> if_statement .)
    LPAREN          reduce using rule 6 (statement -> if_statement .)
    NUMBER          reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    RBRACE          reduce using rule 6 (statement -> if_statement .)
    ELSE            reduce using rule 6 (statement -> if_statement .)
    CONSTRUCTOR     reduce using rule 6 (statement -> if_statement .)


state 7

    (7) statement -> function_def .

    LET             reduce using rule 7 (statement -> function_def .)
    CONST           reduce using rule 7 (statement -> function_def .)
    VAR             reduce using rule 7 (statement -> function_def .)
    IDENTIFIER      reduce using rule 7 (statement -> function_def .)
    THIS            reduce using rule 7 (statement -> function_def .)
    IF              reduce using rule 7 (statement -> function_def .)
    FUNCTION        reduce using rule 7 (statement -> function_def .)
    RETURN          reduce using rule 7 (statement -> function_def .)
    CLASS           reduce using rule 7 (statement -> function_def .)
    WHILE           reduce using rule 7 (statement -> function_def .)
    FOR             reduce using rule 7 (statement -> function_def .)
    BREAK           reduce using rule 7 (statement -> function_def .)
    CONTINUE        reduce using rule 7 (statement -> function_def .)
    NEW             reduce using rule 7 (statement -> function_def .)
    NOT             reduce using rule 7 (statement -> function_def .)
    TRUE            reduce using rule 7 (statement -> function_def .)
    FALSE           reduce using rule 7 (statement -> function_def .)
    LPAREN          reduce using rule 7 (statement -> function_def .)
    NUMBER          reduce using rule 7 (statement -> function_def .)
    $end            reduce using rule 7 (statement -> function_def .)
    RBRACE          reduce using rule 7 (statement -> function_def .)
    ELSE            reduce using rule 7 (statement -> function_def .)
    CONSTRUCTOR     reduce using rule 7 (statement -> function_def .)


state 8

    (8) statement -> return_statement .

    LET             reduce using rule 8 (statement -> return_statement .)
    CONST           reduce using rule 8 (statement -> return_statement .)
    VAR             reduce using rule 8 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 8 (statement -> return_statement .)
    THIS            reduce using rule 8 (statement -> return_statement .)
    IF              reduce using rule 8 (statement -> return_statement .)
    FUNCTION        reduce using rule 8 (statement -> return_statement .)
    RETURN          reduce using rule 8 (statement -> return_statement .)
    CLASS           reduce using rule 8 (statement -> return_statement .)
    WHILE           reduce using rule 8 (statement -> return_statement .)
    FOR             reduce using rule 8 (statement -> return_statement .)
    BREAK           reduce using rule 8 (statement -> return_statement .)
    CONTINUE        reduce using rule 8 (statement -> return_statement .)
    NEW             reduce using rule 8 (statement -> return_statement .)
    NOT             reduce using rule 8 (statement -> return_statement .)
    TRUE            reduce using rule 8 (statement -> return_statement .)
    FALSE           reduce using rule 8 (statement -> return_statement .)
    LPAREN          reduce using rule 8 (statement -> return_statement .)
    NUMBER          reduce using rule 8 (statement -> return_statement .)
    $end            reduce using rule 8 (statement -> return_statement .)
    RBRACE          reduce using rule 8 (statement -> return_statement .)
    ELSE            reduce using rule 8 (statement -> return_statement .)
    CONSTRUCTOR     reduce using rule 8 (statement -> return_statement .)


state 9

    (9) statement -> class_declaration .

    LET             reduce using rule 9 (statement -> class_declaration .)
    CONST           reduce using rule 9 (statement -> class_declaration .)
    VAR             reduce using rule 9 (statement -> class_declaration .)
    IDENTIFIER      reduce using rule 9 (statement -> class_declaration .)
    THIS            reduce using rule 9 (statement -> class_declaration .)
    IF              reduce using rule 9 (statement -> class_declaration .)
    FUNCTION        reduce using rule 9 (statement -> class_declaration .)
    RETURN          reduce using rule 9 (statement -> class_declaration .)
    CLASS           reduce using rule 9 (statement -> class_declaration .)
    WHILE           reduce using rule 9 (statement -> class_declaration .)
    FOR             reduce using rule 9 (statement -> class_declaration .)
    BREAK           reduce using rule 9 (statement -> class_declaration .)
    CONTINUE        reduce using rule 9 (statement -> class_declaration .)
    NEW             reduce using rule 9 (statement -> class_declaration .)
    NOT             reduce using rule 9 (statement -> class_declaration .)
    TRUE            reduce using rule 9 (statement -> class_declaration .)
    FALSE           reduce using rule 9 (statement -> class_declaration .)
    LPAREN          reduce using rule 9 (statement -> class_declaration .)
    NUMBER          reduce using rule 9 (statement -> class_declaration .)
    $end            reduce using rule 9 (statement -> class_declaration .)
    RBRACE          reduce using rule 9 (statement -> class_declaration .)
    ELSE            reduce using rule 9 (statement -> class_declaration .)
    CONSTRUCTOR     reduce using rule 9 (statement -> class_declaration .)


state 10

    (10) statement -> while_statement .

    LET             reduce using rule 10 (statement -> while_statement .)
    CONST           reduce using rule 10 (statement -> while_statement .)
    VAR             reduce using rule 10 (statement -> while_statement .)
    IDENTIFIER      reduce using rule 10 (statement -> while_statement .)
    THIS            reduce using rule 10 (statement -> while_statement .)
    IF              reduce using rule 10 (statement -> while_statement .)
    FUNCTION        reduce using rule 10 (statement -> while_statement .)
    RETURN          reduce using rule 10 (statement -> while_statement .)
    CLASS           reduce using rule 10 (statement -> while_statement .)
    WHILE           reduce using rule 10 (statement -> while_statement .)
    FOR             reduce using rule 10 (statement -> while_statement .)
    BREAK           reduce using rule 10 (statement -> while_statement .)
    CONTINUE        reduce using rule 10 (statement -> while_statement .)
    NEW             reduce using rule 10 (statement -> while_statement .)
    NOT             reduce using rule 10 (statement -> while_statement .)
    TRUE            reduce using rule 10 (statement -> while_statement .)
    FALSE           reduce using rule 10 (statement -> while_statement .)
    LPAREN          reduce using rule 10 (statement -> while_statement .)
    NUMBER          reduce using rule 10 (statement -> while_statement .)
    $end            reduce using rule 10 (statement -> while_statement .)
    RBRACE          reduce using rule 10 (statement -> while_statement .)
    ELSE            reduce using rule 10 (statement -> while_statement .)
    CONSTRUCTOR     reduce using rule 10 (statement -> while_statement .)


state 11

    (11) statement -> for_statement .

    LET             reduce using rule 11 (statement -> for_statement .)
    CONST           reduce using rule 11 (statement -> for_statement .)
    VAR             reduce using rule 11 (statement -> for_statement .)
    IDENTIFIER      reduce using rule 11 (statement -> for_statement .)
    THIS            reduce using rule 11 (statement -> for_statement .)
    IF              reduce using rule 11 (statement -> for_statement .)
    FUNCTION        reduce using rule 11 (statement -> for_statement .)
    RETURN          reduce using rule 11 (statement -> for_statement .)
    CLASS           reduce using rule 11 (statement -> for_statement .)
    WHILE           reduce using rule 11 (statement -> for_statement .)
    FOR             reduce using rule 11 (statement -> for_statement .)
    BREAK           reduce using rule 11 (statement -> for_statement .)
    CONTINUE        reduce using rule 11 (statement -> for_statement .)
    NEW             reduce using rule 11 (statement -> for_statement .)
    NOT             reduce using rule 11 (statement -> for_statement .)
    TRUE            reduce using rule 11 (statement -> for_statement .)
    FALSE           reduce using rule 11 (statement -> for_statement .)
    LPAREN          reduce using rule 11 (statement -> for_statement .)
    NUMBER          reduce using rule 11 (statement -> for_statement .)
    $end            reduce using rule 11 (statement -> for_statement .)
    RBRACE          reduce using rule 11 (statement -> for_statement .)
    ELSE            reduce using rule 11 (statement -> for_statement .)
    CONSTRUCTOR     reduce using rule 11 (statement -> for_statement .)


state 12

    (12) statement -> break_statement .

    LET             reduce using rule 12 (statement -> break_statement .)
    CONST           reduce using rule 12 (statement -> break_statement .)
    VAR             reduce using rule 12 (statement -> break_statement .)
    IDENTIFIER      reduce using rule 12 (statement -> break_statement .)
    THIS            reduce using rule 12 (statement -> break_statement .)
    IF              reduce using rule 12 (statement -> break_statement .)
    FUNCTION        reduce using rule 12 (statement -> break_statement .)
    RETURN          reduce using rule 12 (statement -> break_statement .)
    CLASS           reduce using rule 12 (statement -> break_statement .)
    WHILE           reduce using rule 12 (statement -> break_statement .)
    FOR             reduce using rule 12 (statement -> break_statement .)
    BREAK           reduce using rule 12 (statement -> break_statement .)
    CONTINUE        reduce using rule 12 (statement -> break_statement .)
    NEW             reduce using rule 12 (statement -> break_statement .)
    NOT             reduce using rule 12 (statement -> break_statement .)
    TRUE            reduce using rule 12 (statement -> break_statement .)
    FALSE           reduce using rule 12 (statement -> break_statement .)
    LPAREN          reduce using rule 12 (statement -> break_statement .)
    NUMBER          reduce using rule 12 (statement -> break_statement .)
    $end            reduce using rule 12 (statement -> break_statement .)
    RBRACE          reduce using rule 12 (statement -> break_statement .)
    ELSE            reduce using rule 12 (statement -> break_statement .)
    CONSTRUCTOR     reduce using rule 12 (statement -> break_statement .)


state 13

    (13) statement -> continue_statement .

    LET             reduce using rule 13 (statement -> continue_statement .)
    CONST           reduce using rule 13 (statement -> continue_statement .)
    VAR             reduce using rule 13 (statement -> continue_statement .)
    IDENTIFIER      reduce using rule 13 (statement -> continue_statement .)
    THIS            reduce using rule 13 (statement -> continue_statement .)
    IF              reduce using rule 13 (statement -> continue_statement .)
    FUNCTION        reduce using rule 13 (statement -> continue_statement .)
    RETURN          reduce using rule 13 (statement -> continue_statement .)
    CLASS           reduce using rule 13 (statement -> continue_statement .)
    WHILE           reduce using rule 13 (statement -> continue_statement .)
    FOR             reduce using rule 13 (statement -> continue_statement .)
    BREAK           reduce using rule 13 (statement -> continue_statement .)
    CONTINUE        reduce using rule 13 (statement -> continue_statement .)
    NEW             reduce using rule 13 (statement -> continue_statement .)
    NOT             reduce using rule 13 (statement -> continue_statement .)
    TRUE            reduce using rule 13 (statement -> continue_statement .)
    FALSE           reduce using rule 13 (statement -> continue_statement .)
    LPAREN          reduce using rule 13 (statement -> continue_statement .)
    NUMBER          reduce using rule 13 (statement -> continue_statement .)
    $end            reduce using rule 13 (statement -> continue_statement .)
    RBRACE          reduce using rule 13 (statement -> continue_statement .)
    ELSE            reduce using rule 13 (statement -> continue_statement .)
    CONSTRUCTOR     reduce using rule 13 (statement -> continue_statement .)


state 14

    (14) assignment -> LET . IDENTIFIER EQUALS value
    (15) assignment -> LET . IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> LET . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 48


state 15

    (22) assignment -> IDENTIFIER . EQUALS value
    (23) assignment -> IDENTIFIER . COLON value
    (88) member_access -> IDENTIFIER . DOT IDENTIFIER
    (89) function_call -> IDENTIFIER . LPAREN RPAREN
    (90) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (64) atom -> IDENTIFIER .

    EQUALS          shift and go to state 49
    COLON           shift and go to state 50
    DOT             shift and go to state 51
    LPAREN          shift and go to state 52
    POWER           reduce using rule 64 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 64 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 64 (atom -> IDENTIFIER .)
    MODULE          reduce using rule 64 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 64 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 64 (atom -> IDENTIFIER .)
    EQEQ            reduce using rule 64 (atom -> IDENTIFIER .)
    NOTEQ           reduce using rule 64 (atom -> IDENTIFIER .)
    GT              reduce using rule 64 (atom -> IDENTIFIER .)
    LT              reduce using rule 64 (atom -> IDENTIFIER .)
    GE              reduce using rule 64 (atom -> IDENTIFIER .)
    LE              reduce using rule 64 (atom -> IDENTIFIER .)
    SEMICOLON       reduce using rule 64 (atom -> IDENTIFIER .)


state 16

    (17) assignment -> CONST . IDENTIFIER EQUALS value
    (18) assignment -> CONST . IDENTIFIER COLON data_type EQUALS value

    IDENTIFIER      shift and go to state 53


state 17

    (19) assignment -> VAR . IDENTIFIER EQUALS value
    (20) assignment -> VAR . IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> VAR . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 54


state 18

    (109) assignment -> THIS . DOT IDENTIFIER EQUALS value
    (110) this_access -> THIS . DOT IDENTIFIER
    (111) this_access -> THIS .

    DOT             shift and go to state 55
    SEMICOLON       reduce using rule 111 (this_access -> THIS .)


state 19

    (81) expression -> arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term
    (75) comparison_expression -> arithmetic_expression . EQEQ arithmetic_expression
    (76) comparison_expression -> arithmetic_expression . NOTEQ arithmetic_expression
    (77) comparison_expression -> arithmetic_expression . GT arithmetic_expression
    (78) comparison_expression -> arithmetic_expression . LT arithmetic_expression
    (79) comparison_expression -> arithmetic_expression . GE arithmetic_expression
    (80) comparison_expression -> arithmetic_expression . LE arithmetic_expression

    SEMICOLON       reduce using rule 81 (expression -> arithmetic_expression .)
    RPAREN          reduce using rule 81 (expression -> arithmetic_expression .)
    COMMA           reduce using rule 81 (expression -> arithmetic_expression .)
    RBRACKET        reduce using rule 81 (expression -> arithmetic_expression .)
    RBRACE          reduce using rule 81 (expression -> arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQEQ            shift and go to state 58
    NOTEQ           shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63


state 20

    (82) expression -> logical_expression .
    (66) logical_expression -> logical_expression . AND logical_term
    (67) logical_expression -> logical_expression . OR logical_term

    SEMICOLON       reduce using rule 82 (expression -> logical_expression .)
    RPAREN          reduce using rule 82 (expression -> logical_expression .)
    COMMA           reduce using rule 82 (expression -> logical_expression .)
    RBRACKET        reduce using rule 82 (expression -> logical_expression .)
    RBRACE          reduce using rule 82 (expression -> logical_expression .)
    AND             shift and go to state 64
    OR              shift and go to state 65


state 21

    (83) expression -> member_access .
    (87) member_access -> member_access . DOT IDENTIFIER

    SEMICOLON       reduce using rule 83 (expression -> member_access .)
    RPAREN          reduce using rule 83 (expression -> member_access .)
    COMMA           reduce using rule 83 (expression -> member_access .)
    RBRACKET        reduce using rule 83 (expression -> member_access .)
    RBRACE          reduce using rule 83 (expression -> member_access .)
    DOT             shift and go to state 66


state 22

    (84) expression -> function_call .

    SEMICOLON       reduce using rule 84 (expression -> function_call .)
    RPAREN          reduce using rule 84 (expression -> function_call .)
    COMMA           reduce using rule 84 (expression -> function_call .)
    RBRACKET        reduce using rule 84 (expression -> function_call .)
    RBRACE          reduce using rule 84 (expression -> function_call .)


state 23

    (85) expression -> class_instantiation .

    SEMICOLON       reduce using rule 85 (expression -> class_instantiation .)
    RPAREN          reduce using rule 85 (expression -> class_instantiation .)
    COMMA           reduce using rule 85 (expression -> class_instantiation .)
    RBRACKET        reduce using rule 85 (expression -> class_instantiation .)
    RBRACE          reduce using rule 85 (expression -> class_instantiation .)


state 24

    (86) expression -> this_access .

    SEMICOLON       reduce using rule 86 (expression -> this_access .)
    RPAREN          reduce using rule 86 (expression -> this_access .)
    COMMA           reduce using rule 86 (expression -> this_access .)
    RBRACKET        reduce using rule 86 (expression -> this_access .)
    RBRACE          reduce using rule 86 (expression -> this_access .)


state 25

    (124) if_statement -> IF . LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> IF . LPAREN logical_expression RPAREN statement_block ELSE statement_block

    LPAREN          shift and go to state 67


state 26

    (74) logical_factor -> LPAREN . logical_expression RPAREN
    (65) atom -> LPAREN . arithmetic_expression RPAREN
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_expression             shift and go to state 68
    arithmetic_expression          shift and go to state 69
    logical_term                   shift and go to state 35
    term                           shift and go to state 34
    logical_factor                 shift and go to state 39
    factor                         shift and go to state 37
    comparison_expression          shift and go to state 41
    atom                           shift and go to state 40

state 27

    (112) function_def -> FUNCTION . IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> FUNCTION . IDENTIFIER LPAREN param_list RPAREN statement_block

    IDENTIFIER      shift and go to state 71


state 28

    (118) return_statement -> RETURN . expression SEMICOLON
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    expression                     shift and go to state 72
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 29

    (93) class_declaration -> CLASS . IDENTIFIER LBRACE class_body RBRACE

    IDENTIFIER      shift and go to state 75


state 30

    (121) while_statement -> WHILE . LPAREN logical_expression RPAREN statement_block

    LPAREN          shift and go to state 76


state 31

    (122) for_statement -> FOR . LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> FOR . LPAREN IDENTIFIER IN expression RPAREN statement_block

    LPAREN          shift and go to state 77


state 32

    (126) break_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 78


state 33

    (127) continue_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 79


state 34

    (56) arithmetic_expression -> term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . MODULE factor

    PLUS            reduce using rule 56 (arithmetic_expression -> term .)
    MINUS           reduce using rule 56 (arithmetic_expression -> term .)
    EQEQ            reduce using rule 56 (arithmetic_expression -> term .)
    NOTEQ           reduce using rule 56 (arithmetic_expression -> term .)
    GT              reduce using rule 56 (arithmetic_expression -> term .)
    LT              reduce using rule 56 (arithmetic_expression -> term .)
    GE              reduce using rule 56 (arithmetic_expression -> term .)
    LE              reduce using rule 56 (arithmetic_expression -> term .)
    SEMICOLON       reduce using rule 56 (arithmetic_expression -> term .)
    RPAREN          reduce using rule 56 (arithmetic_expression -> term .)
    COMMA           reduce using rule 56 (arithmetic_expression -> term .)
    AND             reduce using rule 56 (arithmetic_expression -> term .)
    OR              reduce using rule 56 (arithmetic_expression -> term .)
    RBRACKET        reduce using rule 56 (arithmetic_expression -> term .)
    RBRACE          reduce using rule 56 (arithmetic_expression -> term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MODULE          shift and go to state 82


state 35

    (68) logical_expression -> logical_term .

    AND             reduce using rule 68 (logical_expression -> logical_term .)
    OR              reduce using rule 68 (logical_expression -> logical_term .)
    SEMICOLON       reduce using rule 68 (logical_expression -> logical_term .)
    RPAREN          reduce using rule 68 (logical_expression -> logical_term .)
    COMMA           reduce using rule 68 (logical_expression -> logical_term .)
    RBRACKET        reduce using rule 68 (logical_expression -> logical_term .)
    RBRACE          reduce using rule 68 (logical_expression -> logical_term .)


state 36

    (94) class_instantiation -> NEW . IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> NEW . IDENTIFIER LPAREN argument_list RPAREN

    IDENTIFIER      shift and go to state 83


state 37

    (60) term -> factor .

    TIMES           reduce using rule 60 (term -> factor .)
    DIVIDE          reduce using rule 60 (term -> factor .)
    MODULE          reduce using rule 60 (term -> factor .)
    PLUS            reduce using rule 60 (term -> factor .)
    MINUS           reduce using rule 60 (term -> factor .)
    EQEQ            reduce using rule 60 (term -> factor .)
    NOTEQ           reduce using rule 60 (term -> factor .)
    GT              reduce using rule 60 (term -> factor .)
    LT              reduce using rule 60 (term -> factor .)
    GE              reduce using rule 60 (term -> factor .)
    LE              reduce using rule 60 (term -> factor .)
    SEMICOLON       reduce using rule 60 (term -> factor .)
    RPAREN          reduce using rule 60 (term -> factor .)
    COMMA           reduce using rule 60 (term -> factor .)
    AND             reduce using rule 60 (term -> factor .)
    OR              reduce using rule 60 (term -> factor .)
    RBRACKET        reduce using rule 60 (term -> factor .)
    RBRACE          reduce using rule 60 (term -> factor .)


state 38

    (69) logical_term -> NOT . logical_factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_factor                 shift and go to state 84
    comparison_expression          shift and go to state 41
    arithmetic_expression          shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 39

    (70) logical_term -> logical_factor .

    AND             reduce using rule 70 (logical_term -> logical_factor .)
    OR              reduce using rule 70 (logical_term -> logical_factor .)
    SEMICOLON       reduce using rule 70 (logical_term -> logical_factor .)
    RPAREN          reduce using rule 70 (logical_term -> logical_factor .)
    COMMA           reduce using rule 70 (logical_term -> logical_factor .)
    RBRACKET        reduce using rule 70 (logical_term -> logical_factor .)
    RBRACE          reduce using rule 70 (logical_term -> logical_factor .)


state 40

    (61) factor -> atom . POWER factor
    (62) factor -> atom .

    POWER           shift and go to state 86
    TIMES           reduce using rule 62 (factor -> atom .)
    DIVIDE          reduce using rule 62 (factor -> atom .)
    MODULE          reduce using rule 62 (factor -> atom .)
    PLUS            reduce using rule 62 (factor -> atom .)
    MINUS           reduce using rule 62 (factor -> atom .)
    EQEQ            reduce using rule 62 (factor -> atom .)
    NOTEQ           reduce using rule 62 (factor -> atom .)
    GT              reduce using rule 62 (factor -> atom .)
    LT              reduce using rule 62 (factor -> atom .)
    GE              reduce using rule 62 (factor -> atom .)
    LE              reduce using rule 62 (factor -> atom .)
    SEMICOLON       reduce using rule 62 (factor -> atom .)
    RPAREN          reduce using rule 62 (factor -> atom .)
    COMMA           reduce using rule 62 (factor -> atom .)
    AND             reduce using rule 62 (factor -> atom .)
    OR              reduce using rule 62 (factor -> atom .)
    RBRACKET        reduce using rule 62 (factor -> atom .)
    RBRACE          reduce using rule 62 (factor -> atom .)


state 41

    (71) logical_factor -> comparison_expression .

    AND             reduce using rule 71 (logical_factor -> comparison_expression .)
    OR              reduce using rule 71 (logical_factor -> comparison_expression .)
    SEMICOLON       reduce using rule 71 (logical_factor -> comparison_expression .)
    RPAREN          reduce using rule 71 (logical_factor -> comparison_expression .)
    COMMA           reduce using rule 71 (logical_factor -> comparison_expression .)
    RBRACKET        reduce using rule 71 (logical_factor -> comparison_expression .)
    RBRACE          reduce using rule 71 (logical_factor -> comparison_expression .)


state 42

    (72) logical_factor -> TRUE .

    AND             reduce using rule 72 (logical_factor -> TRUE .)
    OR              reduce using rule 72 (logical_factor -> TRUE .)
    SEMICOLON       reduce using rule 72 (logical_factor -> TRUE .)
    RPAREN          reduce using rule 72 (logical_factor -> TRUE .)
    COMMA           reduce using rule 72 (logical_factor -> TRUE .)
    RBRACKET        reduce using rule 72 (logical_factor -> TRUE .)
    RBRACE          reduce using rule 72 (logical_factor -> TRUE .)


state 43

    (73) logical_factor -> FALSE .

    AND             reduce using rule 73 (logical_factor -> FALSE .)
    OR              reduce using rule 73 (logical_factor -> FALSE .)
    SEMICOLON       reduce using rule 73 (logical_factor -> FALSE .)
    RPAREN          reduce using rule 73 (logical_factor -> FALSE .)
    COMMA           reduce using rule 73 (logical_factor -> FALSE .)
    RBRACKET        reduce using rule 73 (logical_factor -> FALSE .)
    RBRACE          reduce using rule 73 (logical_factor -> FALSE .)


state 44

    (63) atom -> NUMBER .

    POWER           reduce using rule 63 (atom -> NUMBER .)
    TIMES           reduce using rule 63 (atom -> NUMBER .)
    DIVIDE          reduce using rule 63 (atom -> NUMBER .)
    MODULE          reduce using rule 63 (atom -> NUMBER .)
    PLUS            reduce using rule 63 (atom -> NUMBER .)
    MINUS           reduce using rule 63 (atom -> NUMBER .)
    EQEQ            reduce using rule 63 (atom -> NUMBER .)
    NOTEQ           reduce using rule 63 (atom -> NUMBER .)
    GT              reduce using rule 63 (atom -> NUMBER .)
    LT              reduce using rule 63 (atom -> NUMBER .)
    GE              reduce using rule 63 (atom -> NUMBER .)
    LE              reduce using rule 63 (atom -> NUMBER .)
    SEMICOLON       reduce using rule 63 (atom -> NUMBER .)
    RPAREN          reduce using rule 63 (atom -> NUMBER .)
    COMMA           reduce using rule 63 (atom -> NUMBER .)
    AND             reduce using rule 63 (atom -> NUMBER .)
    OR              reduce using rule 63 (atom -> NUMBER .)
    RBRACKET        reduce using rule 63 (atom -> NUMBER .)
    RBRACE          reduce using rule 63 (atom -> NUMBER .)


state 45

    (3) statement_list -> statement statement_list .

    $end            reduce using rule 3 (statement_list -> statement statement_list .)
    RBRACE          reduce using rule 3 (statement_list -> statement statement_list .)


state 46

    (4) statement -> assignment SEMICOLON .

    LET             reduce using rule 4 (statement -> assignment SEMICOLON .)
    CONST           reduce using rule 4 (statement -> assignment SEMICOLON .)
    VAR             reduce using rule 4 (statement -> assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 4 (statement -> assignment SEMICOLON .)
    THIS            reduce using rule 4 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 4 (statement -> assignment SEMICOLON .)
    FUNCTION        reduce using rule 4 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 4 (statement -> assignment SEMICOLON .)
    CLASS           reduce using rule 4 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> assignment SEMICOLON .)
    FOR             reduce using rule 4 (statement -> assignment SEMICOLON .)
    BREAK           reduce using rule 4 (statement -> assignment SEMICOLON .)
    CONTINUE        reduce using rule 4 (statement -> assignment SEMICOLON .)
    NEW             reduce using rule 4 (statement -> assignment SEMICOLON .)
    NOT             reduce using rule 4 (statement -> assignment SEMICOLON .)
    TRUE            reduce using rule 4 (statement -> assignment SEMICOLON .)
    FALSE           reduce using rule 4 (statement -> assignment SEMICOLON .)
    LPAREN          reduce using rule 4 (statement -> assignment SEMICOLON .)
    NUMBER          reduce using rule 4 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 4 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> assignment SEMICOLON .)
    ELSE            reduce using rule 4 (statement -> assignment SEMICOLON .)
    CONSTRUCTOR     reduce using rule 4 (statement -> assignment SEMICOLON .)


state 47

    (5) statement -> expression SEMICOLON .

    LET             reduce using rule 5 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 5 (statement -> expression SEMICOLON .)
    VAR             reduce using rule 5 (statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 5 (statement -> expression SEMICOLON .)
    THIS            reduce using rule 5 (statement -> expression SEMICOLON .)
    IF              reduce using rule 5 (statement -> expression SEMICOLON .)
    FUNCTION        reduce using rule 5 (statement -> expression SEMICOLON .)
    RETURN          reduce using rule 5 (statement -> expression SEMICOLON .)
    CLASS           reduce using rule 5 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 5 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 5 (statement -> expression SEMICOLON .)
    BREAK           reduce using rule 5 (statement -> expression SEMICOLON .)
    CONTINUE        reduce using rule 5 (statement -> expression SEMICOLON .)
    NEW             reduce using rule 5 (statement -> expression SEMICOLON .)
    NOT             reduce using rule 5 (statement -> expression SEMICOLON .)
    TRUE            reduce using rule 5 (statement -> expression SEMICOLON .)
    FALSE           reduce using rule 5 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 5 (statement -> expression SEMICOLON .)
    NUMBER          reduce using rule 5 (statement -> expression SEMICOLON .)
    $end            reduce using rule 5 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 5 (statement -> expression SEMICOLON .)
    ELSE            reduce using rule 5 (statement -> expression SEMICOLON .)
    CONSTRUCTOR     reduce using rule 5 (statement -> expression SEMICOLON .)


state 48

    (14) assignment -> LET IDENTIFIER . EQUALS value
    (15) assignment -> LET IDENTIFIER . COLON data_type EQUALS value
    (16) assignment -> LET IDENTIFIER . COLON data_type

    EQUALS          shift and go to state 87
    COLON           shift and go to state 88


state 49

    (22) assignment -> IDENTIFIER EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 89
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 50

    (23) assignment -> IDENTIFIER COLON . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 97
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 51

    (88) member_access -> IDENTIFIER DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 98


state 52

    (89) function_call -> IDENTIFIER LPAREN . RPAREN
    (90) function_call -> IDENTIFIER LPAREN . argument_list RPAREN
    (91) argument_list -> . expression
    (92) argument_list -> . expression COMMA argument_list
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    RPAREN          shift and go to state 99
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    argument_list                  shift and go to state 100
    expression                     shift and go to state 101
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 53

    (17) assignment -> CONST IDENTIFIER . EQUALS value
    (18) assignment -> CONST IDENTIFIER . COLON data_type EQUALS value

    EQUALS          shift and go to state 102
    COLON           shift and go to state 103


state 54

    (19) assignment -> VAR IDENTIFIER . EQUALS value
    (20) assignment -> VAR IDENTIFIER . COLON data_type EQUALS value
    (21) assignment -> VAR IDENTIFIER . COLON data_type

    EQUALS          shift and go to state 104
    COLON           shift and go to state 105


state 55

    (109) assignment -> THIS DOT . IDENTIFIER EQUALS value
    (110) this_access -> THIS DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 106


state 56

    (54) arithmetic_expression -> arithmetic_expression PLUS . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    term                           shift and go to state 107
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 57

    (55) arithmetic_expression -> arithmetic_expression MINUS . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    term                           shift and go to state 109
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 58

    (75) comparison_expression -> arithmetic_expression EQEQ . arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 110
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 59

    (76) comparison_expression -> arithmetic_expression NOTEQ . arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 111
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 60

    (77) comparison_expression -> arithmetic_expression GT . arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 112
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 61

    (78) comparison_expression -> arithmetic_expression LT . arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 113
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 62

    (79) comparison_expression -> arithmetic_expression GE . arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 114
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 63

    (80) comparison_expression -> arithmetic_expression LE . arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 115
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 64

    (66) logical_expression -> logical_expression AND . logical_term
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_term                   shift and go to state 116
    logical_factor                 shift and go to state 39
    comparison_expression          shift and go to state 41
    arithmetic_expression          shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 65

    (67) logical_expression -> logical_expression OR . logical_term
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_term                   shift and go to state 117
    logical_factor                 shift and go to state 39
    comparison_expression          shift and go to state 41
    arithmetic_expression          shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 66

    (87) member_access -> member_access DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 118


state 67

    (124) if_statement -> IF LPAREN . logical_expression RPAREN statement_block
    (125) if_statement -> IF LPAREN . logical_expression RPAREN statement_block ELSE statement_block
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_expression             shift and go to state 119
    logical_term                   shift and go to state 35
    logical_factor                 shift and go to state 39
    comparison_expression          shift and go to state 41
    arithmetic_expression          shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 68

    (74) logical_factor -> LPAREN logical_expression . RPAREN
    (66) logical_expression -> logical_expression . AND logical_term
    (67) logical_expression -> logical_expression . OR logical_term

    RPAREN          shift and go to state 120
    AND             shift and go to state 64
    OR              shift and go to state 65


state 69

    (65) atom -> LPAREN arithmetic_expression . RPAREN
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term
    (75) comparison_expression -> arithmetic_expression . EQEQ arithmetic_expression
    (76) comparison_expression -> arithmetic_expression . NOTEQ arithmetic_expression
    (77) comparison_expression -> arithmetic_expression . GT arithmetic_expression
    (78) comparison_expression -> arithmetic_expression . LT arithmetic_expression
    (79) comparison_expression -> arithmetic_expression . GE arithmetic_expression
    (80) comparison_expression -> arithmetic_expression . LE arithmetic_expression

    RPAREN          shift and go to state 121
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57
    EQEQ            shift and go to state 58
    NOTEQ           shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63


state 70

    (64) atom -> IDENTIFIER .

    POWER           reduce using rule 64 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 64 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 64 (atom -> IDENTIFIER .)
    MODULE          reduce using rule 64 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 64 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 64 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 64 (atom -> IDENTIFIER .)
    EQEQ            reduce using rule 64 (atom -> IDENTIFIER .)
    NOTEQ           reduce using rule 64 (atom -> IDENTIFIER .)
    GT              reduce using rule 64 (atom -> IDENTIFIER .)
    LT              reduce using rule 64 (atom -> IDENTIFIER .)
    GE              reduce using rule 64 (atom -> IDENTIFIER .)
    LE              reduce using rule 64 (atom -> IDENTIFIER .)
    SEMICOLON       reduce using rule 64 (atom -> IDENTIFIER .)
    COMMA           reduce using rule 64 (atom -> IDENTIFIER .)
    AND             reduce using rule 64 (atom -> IDENTIFIER .)
    OR              reduce using rule 64 (atom -> IDENTIFIER .)
    RBRACKET        reduce using rule 64 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 64 (atom -> IDENTIFIER .)


state 71

    (112) function_def -> FUNCTION IDENTIFIER . LPAREN RPAREN statement_block
    (113) function_def -> FUNCTION IDENTIFIER . LPAREN param_list RPAREN statement_block

    LPAREN          shift and go to state 122


state 72

    (118) return_statement -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 123


state 73

    (88) member_access -> IDENTIFIER . DOT IDENTIFIER
    (89) function_call -> IDENTIFIER . LPAREN RPAREN
    (90) function_call -> IDENTIFIER . LPAREN argument_list RPAREN
    (64) atom -> IDENTIFIER .

    DOT             shift and go to state 51
    LPAREN          shift and go to state 52
    POWER           reduce using rule 64 (atom -> IDENTIFIER .)
    TIMES           reduce using rule 64 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 64 (atom -> IDENTIFIER .)
    MODULE          reduce using rule 64 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 64 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 64 (atom -> IDENTIFIER .)
    EQEQ            reduce using rule 64 (atom -> IDENTIFIER .)
    NOTEQ           reduce using rule 64 (atom -> IDENTIFIER .)
    GT              reduce using rule 64 (atom -> IDENTIFIER .)
    LT              reduce using rule 64 (atom -> IDENTIFIER .)
    GE              reduce using rule 64 (atom -> IDENTIFIER .)
    LE              reduce using rule 64 (atom -> IDENTIFIER .)
    SEMICOLON       reduce using rule 64 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 64 (atom -> IDENTIFIER .)
    COMMA           reduce using rule 64 (atom -> IDENTIFIER .)
    RBRACKET        reduce using rule 64 (atom -> IDENTIFIER .)
    RBRACE          reduce using rule 64 (atom -> IDENTIFIER .)


state 74

    (110) this_access -> THIS . DOT IDENTIFIER
    (111) this_access -> THIS .

    DOT             shift and go to state 124
    SEMICOLON       reduce using rule 111 (this_access -> THIS .)
    RPAREN          reduce using rule 111 (this_access -> THIS .)
    COMMA           reduce using rule 111 (this_access -> THIS .)
    RBRACKET        reduce using rule 111 (this_access -> THIS .)
    RBRACE          reduce using rule 111 (this_access -> THIS .)


state 75

    (93) class_declaration -> CLASS IDENTIFIER . LBRACE class_body RBRACE

    LBRACE          shift and go to state 125


state 76

    (121) while_statement -> WHILE LPAREN . logical_expression RPAREN statement_block
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_expression             shift and go to state 126
    logical_term                   shift and go to state 35
    logical_factor                 shift and go to state 39
    comparison_expression          shift and go to state 41
    arithmetic_expression          shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 77

    (122) for_statement -> FOR LPAREN . assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> FOR LPAREN . IDENTIFIER IN expression RPAREN statement_block
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value

    IDENTIFIER      shift and go to state 128
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    THIS            shift and go to state 129

    assignment                     shift and go to state 127

state 78

    (126) break_statement -> BREAK SEMICOLON .

    LET             reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    CONST           reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    VAR             reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    THIS            reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    FUNCTION        reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    CLASS           reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    NEW             reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    NOT             reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    TRUE            reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    FALSE           reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    NUMBER          reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    $end            reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 126 (break_statement -> BREAK SEMICOLON .)
    CONSTRUCTOR     reduce using rule 126 (break_statement -> BREAK SEMICOLON .)


state 79

    (127) continue_statement -> CONTINUE SEMICOLON .

    LET             reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    CONST           reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    VAR             reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    FUNCTION        reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    CLASS           reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    NUMBER          reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    $end            reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)
    CONSTRUCTOR     reduce using rule 127 (continue_statement -> CONTINUE SEMICOLON .)


state 80

    (57) term -> term TIMES . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    factor                         shift and go to state 130
    atom                           shift and go to state 40

state 81

    (58) term -> term DIVIDE . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    factor                         shift and go to state 131
    atom                           shift and go to state 40

state 82

    (59) term -> term MODULE . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    factor                         shift and go to state 132
    atom                           shift and go to state 40

state 83

    (94) class_instantiation -> NEW IDENTIFIER . LPAREN RPAREN
    (95) class_instantiation -> NEW IDENTIFIER . LPAREN argument_list RPAREN

    LPAREN          shift and go to state 133


state 84

    (69) logical_term -> NOT logical_factor .

    AND             reduce using rule 69 (logical_term -> NOT logical_factor .)
    OR              reduce using rule 69 (logical_term -> NOT logical_factor .)
    SEMICOLON       reduce using rule 69 (logical_term -> NOT logical_factor .)
    RPAREN          reduce using rule 69 (logical_term -> NOT logical_factor .)
    COMMA           reduce using rule 69 (logical_term -> NOT logical_factor .)
    RBRACKET        reduce using rule 69 (logical_term -> NOT logical_factor .)
    RBRACE          reduce using rule 69 (logical_term -> NOT logical_factor .)


state 85

    (75) comparison_expression -> arithmetic_expression . EQEQ arithmetic_expression
    (76) comparison_expression -> arithmetic_expression . NOTEQ arithmetic_expression
    (77) comparison_expression -> arithmetic_expression . GT arithmetic_expression
    (78) comparison_expression -> arithmetic_expression . LT arithmetic_expression
    (79) comparison_expression -> arithmetic_expression . GE arithmetic_expression
    (80) comparison_expression -> arithmetic_expression . LE arithmetic_expression
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    EQEQ            shift and go to state 58
    NOTEQ           shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    GE              shift and go to state 62
    LE              shift and go to state 63
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 86

    (61) factor -> atom POWER . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    atom                           shift and go to state 40
    factor                         shift and go to state 134

state 87

    (14) assignment -> LET IDENTIFIER EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 135
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 88

    (15) assignment -> LET IDENTIFIER COLON . data_type EQUALS value
    (16) assignment -> LET IDENTIFIER COLON . data_type
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    ANY             shift and go to state 143
    LBRACE          shift and go to state 144

    data_type                      shift and go to state 136
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142

state 89

    (22) assignment -> IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 22 (assignment -> IDENTIFIER EQUALS value .)
    RPAREN          reduce using rule 22 (assignment -> IDENTIFIER EQUALS value .)


state 90

    (30) value -> STRING .

    SEMICOLON       reduce using rule 30 (value -> STRING .)
    RPAREN          reduce using rule 30 (value -> STRING .)
    COMMA           reduce using rule 30 (value -> STRING .)
    RBRACKET        reduce using rule 30 (value -> STRING .)
    RBRACE          reduce using rule 30 (value -> STRING .)


state 91

    (31) value -> CHARACTER .

    SEMICOLON       reduce using rule 31 (value -> CHARACTER .)
    RPAREN          reduce using rule 31 (value -> CHARACTER .)
    COMMA           reduce using rule 31 (value -> CHARACTER .)
    RBRACKET        reduce using rule 31 (value -> CHARACTER .)
    RBRACE          reduce using rule 31 (value -> CHARACTER .)


state 92

    (32) value -> array .

    SEMICOLON       reduce using rule 32 (value -> array .)
    RPAREN          reduce using rule 32 (value -> array .)
    COMMA           reduce using rule 32 (value -> array .)
    RBRACKET        reduce using rule 32 (value -> array .)
    RBRACE          reduce using rule 32 (value -> array .)


state 93

    (33) value -> object_literal .

    SEMICOLON       reduce using rule 33 (value -> object_literal .)
    RPAREN          reduce using rule 33 (value -> object_literal .)
    COMMA           reduce using rule 33 (value -> object_literal .)
    RBRACKET        reduce using rule 33 (value -> object_literal .)
    RBRACE          reduce using rule 33 (value -> object_literal .)


state 94

    (34) value -> expression .

    SEMICOLON       reduce using rule 34 (value -> expression .)
    RPAREN          reduce using rule 34 (value -> expression .)
    COMMA           reduce using rule 34 (value -> expression .)
    RBRACKET        reduce using rule 34 (value -> expression .)
    RBRACE          reduce using rule 34 (value -> expression .)


state 95

    (39) array -> LBRACKET . RBRACKET
    (40) array -> LBRACKET . element_list RBRACKET
    (41) element_list -> . value
    (42) element_list -> . value COMMA element_list
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    RBRACKET        shift and go to state 145
    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    element_list                   shift and go to state 146
    value                          shift and go to state 147
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 96

    (45) object_literal -> LBRACE . property_assignment_list RBRACE
    (47) property_assignment_list -> . property_assignment
    (48) property_assignment_list -> . property_assignment COMMA property_assignment_list
    (49) property_assignment -> . IDENTIFIER COLON value
    (50) property_assignment -> . STRING COLON value

    IDENTIFIER      shift and go to state 150
    STRING          shift and go to state 151

    property_assignment_list       shift and go to state 148
    property_assignment            shift and go to state 149

state 97

    (23) assignment -> IDENTIFIER COLON value .

    SEMICOLON       reduce using rule 23 (assignment -> IDENTIFIER COLON value .)
    RPAREN          reduce using rule 23 (assignment -> IDENTIFIER COLON value .)


state 98

    (88) member_access -> IDENTIFIER DOT IDENTIFIER .

    DOT             reduce using rule 88 (member_access -> IDENTIFIER DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 88 (member_access -> IDENTIFIER DOT IDENTIFIER .)
    RPAREN          reduce using rule 88 (member_access -> IDENTIFIER DOT IDENTIFIER .)
    COMMA           reduce using rule 88 (member_access -> IDENTIFIER DOT IDENTIFIER .)
    RBRACKET        reduce using rule 88 (member_access -> IDENTIFIER DOT IDENTIFIER .)
    RBRACE          reduce using rule 88 (member_access -> IDENTIFIER DOT IDENTIFIER .)


state 99

    (89) function_call -> IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 89 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 89 (function_call -> IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 89 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 89 (function_call -> IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 89 (function_call -> IDENTIFIER LPAREN RPAREN .)


state 100

    (90) function_call -> IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 152


state 101

    (91) argument_list -> expression .
    (92) argument_list -> expression . COMMA argument_list

    RPAREN          reduce using rule 91 (argument_list -> expression .)
    COMMA           shift and go to state 153


state 102

    (17) assignment -> CONST IDENTIFIER EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 154
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 103

    (18) assignment -> CONST IDENTIFIER COLON . data_type EQUALS value
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    ANY             shift and go to state 143
    LBRACE          shift and go to state 144

    data_type                      shift and go to state 155
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142

state 104

    (19) assignment -> VAR IDENTIFIER EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 156
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 105

    (20) assignment -> VAR IDENTIFIER COLON . data_type EQUALS value
    (21) assignment -> VAR IDENTIFIER COLON . data_type
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    ANY             shift and go to state 143
    LBRACE          shift and go to state 144

    data_type                      shift and go to state 157
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142

state 106

    (109) assignment -> THIS DOT IDENTIFIER . EQUALS value
    (110) this_access -> THIS DOT IDENTIFIER .

    EQUALS          shift and go to state 158
    SEMICOLON       reduce using rule 110 (this_access -> THIS DOT IDENTIFIER .)


state 107

    (54) arithmetic_expression -> arithmetic_expression PLUS term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . MODULE factor

    PLUS            reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    MINUS           reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    EQEQ            reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    NOTEQ           reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    GT              reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    LT              reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    GE              reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    LE              reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    SEMICOLON       reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RPAREN          reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    COMMA           reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    AND             reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    OR              reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RBRACKET        reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    RBRACE          reduce using rule 54 (arithmetic_expression -> arithmetic_expression PLUS term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MODULE          shift and go to state 82


state 108

    (65) atom -> LPAREN . arithmetic_expression RPAREN
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70
    LPAREN          shift and go to state 108

    arithmetic_expression          shift and go to state 159
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 109

    (55) arithmetic_expression -> arithmetic_expression MINUS term .
    (57) term -> term . TIMES factor
    (58) term -> term . DIVIDE factor
    (59) term -> term . MODULE factor

    PLUS            reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    MINUS           reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    EQEQ            reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    NOTEQ           reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    GT              reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    LT              reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    GE              reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    LE              reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    SEMICOLON       reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RPAREN          reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    COMMA           reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    AND             reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    OR              reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RBRACKET        reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    RBRACE          reduce using rule 55 (arithmetic_expression -> arithmetic_expression MINUS term .)
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    MODULE          shift and go to state 82


state 110

    (75) comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    OR              reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    SEMICOLON       reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    RPAREN          reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    COMMA           reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    RBRACKET        reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    RBRACE          reduce using rule 75 (comparison_expression -> arithmetic_expression EQEQ arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 111

    (76) comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    OR              reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    SEMICOLON       reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    RPAREN          reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    COMMA           reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    RBRACKET        reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    RBRACE          reduce using rule 76 (comparison_expression -> arithmetic_expression NOTEQ arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 112

    (77) comparison_expression -> arithmetic_expression GT arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    OR              reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    SEMICOLON       reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    RPAREN          reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    COMMA           reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    RBRACKET        reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    RBRACE          reduce using rule 77 (comparison_expression -> arithmetic_expression GT arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 113

    (78) comparison_expression -> arithmetic_expression LT arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    OR              reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    SEMICOLON       reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    RPAREN          reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    COMMA           reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    RBRACKET        reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    RBRACE          reduce using rule 78 (comparison_expression -> arithmetic_expression LT arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 114

    (79) comparison_expression -> arithmetic_expression GE arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    OR              reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    SEMICOLON       reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    RPAREN          reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    COMMA           reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    RBRACKET        reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    RBRACE          reduce using rule 79 (comparison_expression -> arithmetic_expression GE arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 115

    (80) comparison_expression -> arithmetic_expression LE arithmetic_expression .
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    AND             reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    OR              reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    SEMICOLON       reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    RPAREN          reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    COMMA           reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    RBRACKET        reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    RBRACE          reduce using rule 80 (comparison_expression -> arithmetic_expression LE arithmetic_expression .)
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 116

    (66) logical_expression -> logical_expression AND logical_term .

    AND             reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)
    OR              reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)
    SEMICOLON       reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)
    RPAREN          reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)
    COMMA           reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)
    RBRACKET        reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)
    RBRACE          reduce using rule 66 (logical_expression -> logical_expression AND logical_term .)


state 117

    (67) logical_expression -> logical_expression OR logical_term .

    AND             reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)
    OR              reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)
    SEMICOLON       reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)
    RPAREN          reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)
    COMMA           reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)
    RBRACKET        reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)
    RBRACE          reduce using rule 67 (logical_expression -> logical_expression OR logical_term .)


state 118

    (87) member_access -> member_access DOT IDENTIFIER .

    DOT             reduce using rule 87 (member_access -> member_access DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 87 (member_access -> member_access DOT IDENTIFIER .)
    RPAREN          reduce using rule 87 (member_access -> member_access DOT IDENTIFIER .)
    COMMA           reduce using rule 87 (member_access -> member_access DOT IDENTIFIER .)
    RBRACKET        reduce using rule 87 (member_access -> member_access DOT IDENTIFIER .)
    RBRACE          reduce using rule 87 (member_access -> member_access DOT IDENTIFIER .)


state 119

    (124) if_statement -> IF LPAREN logical_expression . RPAREN statement_block
    (125) if_statement -> IF LPAREN logical_expression . RPAREN statement_block ELSE statement_block
    (66) logical_expression -> logical_expression . AND logical_term
    (67) logical_expression -> logical_expression . OR logical_term

    RPAREN          shift and go to state 160
    AND             shift and go to state 64
    OR              shift and go to state 65


state 120

    (74) logical_factor -> LPAREN logical_expression RPAREN .

    AND             reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)
    OR              reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)
    SEMICOLON       reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)
    RPAREN          reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)
    COMMA           reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)
    RBRACKET        reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)
    RBRACE          reduce using rule 74 (logical_factor -> LPAREN logical_expression RPAREN .)


state 121

    (65) atom -> LPAREN arithmetic_expression RPAREN .

    POWER           reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    TIMES           reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    DIVIDE          reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    MODULE          reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    PLUS            reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    MINUS           reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    EQEQ            reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    NOTEQ           reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    GT              reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    LT              reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    GE              reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    LE              reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    SEMICOLON       reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    RPAREN          reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    COMMA           reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    AND             reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    OR              reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    RBRACKET        reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)
    RBRACE          reduce using rule 65 (atom -> LPAREN arithmetic_expression RPAREN .)


state 122

    (112) function_def -> FUNCTION IDENTIFIER LPAREN . RPAREN statement_block
    (113) function_def -> FUNCTION IDENTIFIER LPAREN . param_list RPAREN statement_block
    (114) param_list -> . IDENTIFIER
    (115) param_list -> . IDENTIFIER COMMA param_list
    (116) param_list -> . IDENTIFIER COLON data_type
    (117) param_list -> . IDENTIFIER COLON data_type COMMA param_list

    RPAREN          shift and go to state 162
    IDENTIFIER      shift and go to state 161

    param_list                     shift and go to state 163

state 123

    (118) return_statement -> RETURN expression SEMICOLON .

    LET             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    CONST           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    VAR             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    THIS            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    FUNCTION        reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    CLASS           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    TRUE            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    FALSE           reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    NUMBER          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    $end            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)
    CONSTRUCTOR     reduce using rule 118 (return_statement -> RETURN expression SEMICOLON .)


state 124

    (110) this_access -> THIS DOT . IDENTIFIER

    IDENTIFIER      shift and go to state 164


state 125

    (93) class_declaration -> CLASS IDENTIFIER LBRACE . class_body RBRACE
    (96) class_body -> . class_member_list
    (97) class_body -> . empty
    (98) class_member_list -> . class_member
    (99) class_member_list -> . class_member class_member_list
    (104) empty -> .
    (100) class_member -> . assignment SEMICOLON
    (101) class_member -> . class_property
    (102) class_member -> . function_def
    (103) class_member -> . constructor
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (105) class_property -> . IDENTIFIER COLON data_type SEMICOLON
    (106) class_property -> . IDENTIFIER COLON data_type EQUALS value SEMICOLON
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (107) constructor -> . CONSTRUCTOR LPAREN RPAREN statement_block
    (108) constructor -> . CONSTRUCTOR LPAREN param_list RPAREN statement_block

    RBRACE          reduce using rule 104 (empty -> .)
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 165
    THIS            shift and go to state 129
    FUNCTION        shift and go to state 27
    CONSTRUCTOR     shift and go to state 174

    class_body                     shift and go to state 166
    class_member_list              shift and go to state 167
    empty                          shift and go to state 168
    class_member                   shift and go to state 169
    assignment                     shift and go to state 170
    class_property                 shift and go to state 171
    function_def                   shift and go to state 172
    constructor                    shift and go to state 173

state 126

    (121) while_statement -> WHILE LPAREN logical_expression . RPAREN statement_block
    (66) logical_expression -> logical_expression . AND logical_term
    (67) logical_expression -> logical_expression . OR logical_term

    RPAREN          shift and go to state 175
    AND             shift and go to state 64
    OR              shift and go to state 65


state 127

    (122) for_statement -> FOR LPAREN assignment . SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block

    SEMICOLON       shift and go to state 176


state 128

    (123) for_statement -> FOR LPAREN IDENTIFIER . IN expression RPAREN statement_block
    (22) assignment -> IDENTIFIER . EQUALS value
    (23) assignment -> IDENTIFIER . COLON value

    IN              shift and go to state 177
    EQUALS          shift and go to state 49
    COLON           shift and go to state 50


state 129

    (109) assignment -> THIS . DOT IDENTIFIER EQUALS value

    DOT             shift and go to state 178


state 130

    (57) term -> term TIMES factor .

    TIMES           reduce using rule 57 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 57 (term -> term TIMES factor .)
    MODULE          reduce using rule 57 (term -> term TIMES factor .)
    PLUS            reduce using rule 57 (term -> term TIMES factor .)
    MINUS           reduce using rule 57 (term -> term TIMES factor .)
    EQEQ            reduce using rule 57 (term -> term TIMES factor .)
    NOTEQ           reduce using rule 57 (term -> term TIMES factor .)
    GT              reduce using rule 57 (term -> term TIMES factor .)
    LT              reduce using rule 57 (term -> term TIMES factor .)
    GE              reduce using rule 57 (term -> term TIMES factor .)
    LE              reduce using rule 57 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 57 (term -> term TIMES factor .)
    RPAREN          reduce using rule 57 (term -> term TIMES factor .)
    COMMA           reduce using rule 57 (term -> term TIMES factor .)
    AND             reduce using rule 57 (term -> term TIMES factor .)
    OR              reduce using rule 57 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 57 (term -> term TIMES factor .)
    RBRACE          reduce using rule 57 (term -> term TIMES factor .)


state 131

    (58) term -> term DIVIDE factor .

    TIMES           reduce using rule 58 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 58 (term -> term DIVIDE factor .)
    MODULE          reduce using rule 58 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 58 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 58 (term -> term DIVIDE factor .)
    EQEQ            reduce using rule 58 (term -> term DIVIDE factor .)
    NOTEQ           reduce using rule 58 (term -> term DIVIDE factor .)
    GT              reduce using rule 58 (term -> term DIVIDE factor .)
    LT              reduce using rule 58 (term -> term DIVIDE factor .)
    GE              reduce using rule 58 (term -> term DIVIDE factor .)
    LE              reduce using rule 58 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 58 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 58 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 58 (term -> term DIVIDE factor .)
    AND             reduce using rule 58 (term -> term DIVIDE factor .)
    OR              reduce using rule 58 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 58 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 58 (term -> term DIVIDE factor .)


state 132

    (59) term -> term MODULE factor .

    TIMES           reduce using rule 59 (term -> term MODULE factor .)
    DIVIDE          reduce using rule 59 (term -> term MODULE factor .)
    MODULE          reduce using rule 59 (term -> term MODULE factor .)
    PLUS            reduce using rule 59 (term -> term MODULE factor .)
    MINUS           reduce using rule 59 (term -> term MODULE factor .)
    EQEQ            reduce using rule 59 (term -> term MODULE factor .)
    NOTEQ           reduce using rule 59 (term -> term MODULE factor .)
    GT              reduce using rule 59 (term -> term MODULE factor .)
    LT              reduce using rule 59 (term -> term MODULE factor .)
    GE              reduce using rule 59 (term -> term MODULE factor .)
    LE              reduce using rule 59 (term -> term MODULE factor .)
    SEMICOLON       reduce using rule 59 (term -> term MODULE factor .)
    RPAREN          reduce using rule 59 (term -> term MODULE factor .)
    COMMA           reduce using rule 59 (term -> term MODULE factor .)
    AND             reduce using rule 59 (term -> term MODULE factor .)
    OR              reduce using rule 59 (term -> term MODULE factor .)
    RBRACKET        reduce using rule 59 (term -> term MODULE factor .)
    RBRACE          reduce using rule 59 (term -> term MODULE factor .)


state 133

    (94) class_instantiation -> NEW IDENTIFIER LPAREN . RPAREN
    (95) class_instantiation -> NEW IDENTIFIER LPAREN . argument_list RPAREN
    (91) argument_list -> . expression
    (92) argument_list -> . expression COMMA argument_list
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    RPAREN          shift and go to state 179
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    argument_list                  shift and go to state 180
    expression                     shift and go to state 101
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 134

    (61) factor -> atom POWER factor .

    TIMES           reduce using rule 61 (factor -> atom POWER factor .)
    DIVIDE          reduce using rule 61 (factor -> atom POWER factor .)
    MODULE          reduce using rule 61 (factor -> atom POWER factor .)
    PLUS            reduce using rule 61 (factor -> atom POWER factor .)
    MINUS           reduce using rule 61 (factor -> atom POWER factor .)
    EQEQ            reduce using rule 61 (factor -> atom POWER factor .)
    NOTEQ           reduce using rule 61 (factor -> atom POWER factor .)
    GT              reduce using rule 61 (factor -> atom POWER factor .)
    LT              reduce using rule 61 (factor -> atom POWER factor .)
    GE              reduce using rule 61 (factor -> atom POWER factor .)
    LE              reduce using rule 61 (factor -> atom POWER factor .)
    SEMICOLON       reduce using rule 61 (factor -> atom POWER factor .)
    RPAREN          reduce using rule 61 (factor -> atom POWER factor .)
    COMMA           reduce using rule 61 (factor -> atom POWER factor .)
    AND             reduce using rule 61 (factor -> atom POWER factor .)
    OR              reduce using rule 61 (factor -> atom POWER factor .)
    RBRACKET        reduce using rule 61 (factor -> atom POWER factor .)
    RBRACE          reduce using rule 61 (factor -> atom POWER factor .)


state 135

    (14) assignment -> LET IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 14 (assignment -> LET IDENTIFIER EQUALS value .)
    RPAREN          reduce using rule 14 (assignment -> LET IDENTIFIER EQUALS value .)


state 136

    (15) assignment -> LET IDENTIFIER COLON data_type . EQUALS value
    (16) assignment -> LET IDENTIFIER COLON data_type .

    EQUALS          shift and go to state 181
    SEMICOLON       reduce using rule 16 (assignment -> LET IDENTIFIER COLON data_type .)
    RPAREN          reduce using rule 16 (assignment -> LET IDENTIFIER COLON data_type .)


state 137

    (24) data_type -> STRING_TYPE .
    (36) array_type -> STRING_TYPE . LBRACKET RBRACKET

    EQUALS          reduce using rule 24 (data_type -> STRING_TYPE .)
    SEMICOLON       reduce using rule 24 (data_type -> STRING_TYPE .)
    RPAREN          reduce using rule 24 (data_type -> STRING_TYPE .)
    COMMA           reduce using rule 24 (data_type -> STRING_TYPE .)
    RBRACE          reduce using rule 24 (data_type -> STRING_TYPE .)
    LBRACKET        shift and go to state 182


state 138

    (25) data_type -> NUMBER_TYPE .
    (35) array_type -> NUMBER_TYPE . LBRACKET RBRACKET

    EQUALS          reduce using rule 25 (data_type -> NUMBER_TYPE .)
    SEMICOLON       reduce using rule 25 (data_type -> NUMBER_TYPE .)
    RPAREN          reduce using rule 25 (data_type -> NUMBER_TYPE .)
    COMMA           reduce using rule 25 (data_type -> NUMBER_TYPE .)
    RBRACE          reduce using rule 25 (data_type -> NUMBER_TYPE .)
    LBRACKET        shift and go to state 183


state 139

    (26) data_type -> BOOLEAN_TYPE .
    (37) array_type -> BOOLEAN_TYPE . LBRACKET RBRACKET

    EQUALS          reduce using rule 26 (data_type -> BOOLEAN_TYPE .)
    SEMICOLON       reduce using rule 26 (data_type -> BOOLEAN_TYPE .)
    RPAREN          reduce using rule 26 (data_type -> BOOLEAN_TYPE .)
    COMMA           reduce using rule 26 (data_type -> BOOLEAN_TYPE .)
    RBRACE          reduce using rule 26 (data_type -> BOOLEAN_TYPE .)
    LBRACKET        shift and go to state 184


state 140

    (27) data_type -> CHAR_TYPE .

    EQUALS          reduce using rule 27 (data_type -> CHAR_TYPE .)
    SEMICOLON       reduce using rule 27 (data_type -> CHAR_TYPE .)
    RPAREN          reduce using rule 27 (data_type -> CHAR_TYPE .)
    COMMA           reduce using rule 27 (data_type -> CHAR_TYPE .)
    RBRACE          reduce using rule 27 (data_type -> CHAR_TYPE .)


state 141

    (28) data_type -> array_type .

    EQUALS          reduce using rule 28 (data_type -> array_type .)
    SEMICOLON       reduce using rule 28 (data_type -> array_type .)
    RPAREN          reduce using rule 28 (data_type -> array_type .)
    COMMA           reduce using rule 28 (data_type -> array_type .)
    RBRACE          reduce using rule 28 (data_type -> array_type .)


state 142

    (29) data_type -> object_type_literal .

    EQUALS          reduce using rule 29 (data_type -> object_type_literal .)
    SEMICOLON       reduce using rule 29 (data_type -> object_type_literal .)
    RPAREN          reduce using rule 29 (data_type -> object_type_literal .)
    COMMA           reduce using rule 29 (data_type -> object_type_literal .)
    RBRACE          reduce using rule 29 (data_type -> object_type_literal .)


state 143

    (38) array_type -> ANY . LBRACKET RBRACKET

    LBRACKET        shift and go to state 185


state 144

    (43) object_type_literal -> LBRACE . property_list RBRACE
    (44) object_type_literal -> LBRACE . RBRACE
    (51) property_list -> . property
    (52) property_list -> . property SEMICOLON property_list
    (53) property_list -> . property COMMA property_list
    (46) property -> . IDENTIFIER COLON data_type

    RBRACE          shift and go to state 187
    IDENTIFIER      shift and go to state 189

    property_list                  shift and go to state 186
    property                       shift and go to state 188

state 145

    (39) array -> LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 39 (array -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 39 (array -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 39 (array -> LBRACKET RBRACKET .)


state 146

    (40) array -> LBRACKET element_list . RBRACKET

    RBRACKET        shift and go to state 190


state 147

    (41) element_list -> value .
    (42) element_list -> value . COMMA element_list

    RBRACKET        reduce using rule 41 (element_list -> value .)
    COMMA           shift and go to state 191


state 148

    (45) object_literal -> LBRACE property_assignment_list . RBRACE

    RBRACE          shift and go to state 192


state 149

    (47) property_assignment_list -> property_assignment .
    (48) property_assignment_list -> property_assignment . COMMA property_assignment_list

    RBRACE          reduce using rule 47 (property_assignment_list -> property_assignment .)
    COMMA           shift and go to state 193


state 150

    (49) property_assignment -> IDENTIFIER . COLON value

    COLON           shift and go to state 194


state 151

    (50) property_assignment -> STRING . COLON value

    COLON           shift and go to state 195


state 152

    (90) function_call -> IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 90 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 90 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 90 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 90 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 90 (function_call -> IDENTIFIER LPAREN argument_list RPAREN .)


state 153

    (92) argument_list -> expression COMMA . argument_list
    (91) argument_list -> . expression
    (92) argument_list -> . expression COMMA argument_list
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    expression                     shift and go to state 101
    argument_list                  shift and go to state 196
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 154

    (17) assignment -> CONST IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 17 (assignment -> CONST IDENTIFIER EQUALS value .)
    RPAREN          reduce using rule 17 (assignment -> CONST IDENTIFIER EQUALS value .)


state 155

    (18) assignment -> CONST IDENTIFIER COLON data_type . EQUALS value

    EQUALS          shift and go to state 197


state 156

    (19) assignment -> VAR IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 19 (assignment -> VAR IDENTIFIER EQUALS value .)
    RPAREN          reduce using rule 19 (assignment -> VAR IDENTIFIER EQUALS value .)


state 157

    (20) assignment -> VAR IDENTIFIER COLON data_type . EQUALS value
    (21) assignment -> VAR IDENTIFIER COLON data_type .

    EQUALS          shift and go to state 198
    SEMICOLON       reduce using rule 21 (assignment -> VAR IDENTIFIER COLON data_type .)
    RPAREN          reduce using rule 21 (assignment -> VAR IDENTIFIER COLON data_type .)


state 158

    (109) assignment -> THIS DOT IDENTIFIER EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 199
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 159

    (65) atom -> LPAREN arithmetic_expression . RPAREN
    (54) arithmetic_expression -> arithmetic_expression . PLUS term
    (55) arithmetic_expression -> arithmetic_expression . MINUS term

    RPAREN          shift and go to state 121
    PLUS            shift and go to state 56
    MINUS           shift and go to state 57


state 160

    (124) if_statement -> IF LPAREN logical_expression RPAREN . statement_block
    (125) if_statement -> IF LPAREN logical_expression RPAREN . statement_block ELSE statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    logical_expression             shift and go to state 20
    statement_block                shift and go to state 200
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 161

    (114) param_list -> IDENTIFIER .
    (115) param_list -> IDENTIFIER . COMMA param_list
    (116) param_list -> IDENTIFIER . COLON data_type
    (117) param_list -> IDENTIFIER . COLON data_type COMMA param_list

    RPAREN          reduce using rule 114 (param_list -> IDENTIFIER .)
    COMMA           shift and go to state 203
    COLON           shift and go to state 204


state 162

    (112) function_def -> FUNCTION IDENTIFIER LPAREN RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    statement_block                shift and go to state 205
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 163

    (113) function_def -> FUNCTION IDENTIFIER LPAREN param_list . RPAREN statement_block

    RPAREN          shift and go to state 206


state 164

    (110) this_access -> THIS DOT IDENTIFIER .

    SEMICOLON       reduce using rule 110 (this_access -> THIS DOT IDENTIFIER .)
    RPAREN          reduce using rule 110 (this_access -> THIS DOT IDENTIFIER .)
    COMMA           reduce using rule 110 (this_access -> THIS DOT IDENTIFIER .)
    RBRACKET        reduce using rule 110 (this_access -> THIS DOT IDENTIFIER .)
    RBRACE          reduce using rule 110 (this_access -> THIS DOT IDENTIFIER .)


state 165

    (22) assignment -> IDENTIFIER . EQUALS value
    (23) assignment -> IDENTIFIER . COLON value
    (105) class_property -> IDENTIFIER . COLON data_type SEMICOLON
    (106) class_property -> IDENTIFIER . COLON data_type EQUALS value SEMICOLON

    EQUALS          shift and go to state 49
    COLON           shift and go to state 207


state 166

    (93) class_declaration -> CLASS IDENTIFIER LBRACE class_body . RBRACE

    RBRACE          shift and go to state 208


state 167

    (96) class_body -> class_member_list .

    RBRACE          reduce using rule 96 (class_body -> class_member_list .)


state 168

    (97) class_body -> empty .

    RBRACE          reduce using rule 97 (class_body -> empty .)


state 169

    (98) class_member_list -> class_member .
    (99) class_member_list -> class_member . class_member_list
    (98) class_member_list -> . class_member
    (99) class_member_list -> . class_member class_member_list
    (100) class_member -> . assignment SEMICOLON
    (101) class_member -> . class_property
    (102) class_member -> . function_def
    (103) class_member -> . constructor
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (105) class_property -> . IDENTIFIER COLON data_type SEMICOLON
    (106) class_property -> . IDENTIFIER COLON data_type EQUALS value SEMICOLON
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (107) constructor -> . CONSTRUCTOR LPAREN RPAREN statement_block
    (108) constructor -> . CONSTRUCTOR LPAREN param_list RPAREN statement_block

    RBRACE          reduce using rule 98 (class_member_list -> class_member .)
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 165
    THIS            shift and go to state 129
    FUNCTION        shift and go to state 27
    CONSTRUCTOR     shift and go to state 174

    class_member                   shift and go to state 169
    class_member_list              shift and go to state 209
    assignment                     shift and go to state 170
    class_property                 shift and go to state 171
    function_def                   shift and go to state 172
    constructor                    shift and go to state 173

state 170

    (100) class_member -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 210


state 171

    (101) class_member -> class_property .

    LET             reduce using rule 101 (class_member -> class_property .)
    CONST           reduce using rule 101 (class_member -> class_property .)
    VAR             reduce using rule 101 (class_member -> class_property .)
    IDENTIFIER      reduce using rule 101 (class_member -> class_property .)
    THIS            reduce using rule 101 (class_member -> class_property .)
    FUNCTION        reduce using rule 101 (class_member -> class_property .)
    CONSTRUCTOR     reduce using rule 101 (class_member -> class_property .)
    RBRACE          reduce using rule 101 (class_member -> class_property .)


state 172

    (102) class_member -> function_def .

    LET             reduce using rule 102 (class_member -> function_def .)
    CONST           reduce using rule 102 (class_member -> function_def .)
    VAR             reduce using rule 102 (class_member -> function_def .)
    IDENTIFIER      reduce using rule 102 (class_member -> function_def .)
    THIS            reduce using rule 102 (class_member -> function_def .)
    FUNCTION        reduce using rule 102 (class_member -> function_def .)
    CONSTRUCTOR     reduce using rule 102 (class_member -> function_def .)
    RBRACE          reduce using rule 102 (class_member -> function_def .)


state 173

    (103) class_member -> constructor .

    LET             reduce using rule 103 (class_member -> constructor .)
    CONST           reduce using rule 103 (class_member -> constructor .)
    VAR             reduce using rule 103 (class_member -> constructor .)
    IDENTIFIER      reduce using rule 103 (class_member -> constructor .)
    THIS            reduce using rule 103 (class_member -> constructor .)
    FUNCTION        reduce using rule 103 (class_member -> constructor .)
    CONSTRUCTOR     reduce using rule 103 (class_member -> constructor .)
    RBRACE          reduce using rule 103 (class_member -> constructor .)


state 174

    (107) constructor -> CONSTRUCTOR . LPAREN RPAREN statement_block
    (108) constructor -> CONSTRUCTOR . LPAREN param_list RPAREN statement_block

    LPAREN          shift and go to state 211


state 175

    (121) while_statement -> WHILE LPAREN logical_expression RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    logical_expression             shift and go to state 20
    statement_block                shift and go to state 212
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 176

    (122) for_statement -> FOR LPAREN assignment SEMICOLON . logical_expression SEMICOLON assignment RPAREN statement_block
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN

    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44
    IDENTIFIER      shift and go to state 70

    logical_expression             shift and go to state 213
    logical_term                   shift and go to state 35
    logical_factor                 shift and go to state 39
    comparison_expression          shift and go to state 41
    arithmetic_expression          shift and go to state 85
    term                           shift and go to state 34
    factor                         shift and go to state 37
    atom                           shift and go to state 40

state 177

    (123) for_statement -> FOR LPAREN IDENTIFIER IN . expression RPAREN statement_block
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    expression                     shift and go to state 214
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 178

    (109) assignment -> THIS DOT . IDENTIFIER EQUALS value

    IDENTIFIER      shift and go to state 215


state 179

    (94) class_instantiation -> NEW IDENTIFIER LPAREN RPAREN .

    SEMICOLON       reduce using rule 94 (class_instantiation -> NEW IDENTIFIER LPAREN RPAREN .)
    RPAREN          reduce using rule 94 (class_instantiation -> NEW IDENTIFIER LPAREN RPAREN .)
    COMMA           reduce using rule 94 (class_instantiation -> NEW IDENTIFIER LPAREN RPAREN .)
    RBRACKET        reduce using rule 94 (class_instantiation -> NEW IDENTIFIER LPAREN RPAREN .)
    RBRACE          reduce using rule 94 (class_instantiation -> NEW IDENTIFIER LPAREN RPAREN .)


state 180

    (95) class_instantiation -> NEW IDENTIFIER LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 216


state 181

    (15) assignment -> LET IDENTIFIER COLON data_type EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 217
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 182

    (36) array_type -> STRING_TYPE LBRACKET . RBRACKET

    RBRACKET        shift and go to state 218


state 183

    (35) array_type -> NUMBER_TYPE LBRACKET . RBRACKET

    RBRACKET        shift and go to state 219


state 184

    (37) array_type -> BOOLEAN_TYPE LBRACKET . RBRACKET

    RBRACKET        shift and go to state 220


state 185

    (38) array_type -> ANY LBRACKET . RBRACKET

    RBRACKET        shift and go to state 221


state 186

    (43) object_type_literal -> LBRACE property_list . RBRACE

    RBRACE          shift and go to state 222


state 187

    (44) object_type_literal -> LBRACE RBRACE .

    EQUALS          reduce using rule 44 (object_type_literal -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 44 (object_type_literal -> LBRACE RBRACE .)
    RPAREN          reduce using rule 44 (object_type_literal -> LBRACE RBRACE .)
    COMMA           reduce using rule 44 (object_type_literal -> LBRACE RBRACE .)
    RBRACE          reduce using rule 44 (object_type_literal -> LBRACE RBRACE .)


state 188

    (51) property_list -> property .
    (52) property_list -> property . SEMICOLON property_list
    (53) property_list -> property . COMMA property_list

    RBRACE          reduce using rule 51 (property_list -> property .)
    SEMICOLON       shift and go to state 223
    COMMA           shift and go to state 224


state 189

    (46) property -> IDENTIFIER . COLON data_type

    COLON           shift and go to state 225


state 190

    (40) array -> LBRACKET element_list RBRACKET .

    SEMICOLON       reduce using rule 40 (array -> LBRACKET element_list RBRACKET .)
    RPAREN          reduce using rule 40 (array -> LBRACKET element_list RBRACKET .)
    COMMA           reduce using rule 40 (array -> LBRACKET element_list RBRACKET .)
    RBRACKET        reduce using rule 40 (array -> LBRACKET element_list RBRACKET .)
    RBRACE          reduce using rule 40 (array -> LBRACKET element_list RBRACKET .)


state 191

    (42) element_list -> value COMMA . element_list
    (41) element_list -> . value
    (42) element_list -> . value COMMA element_list
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 147
    element_list                   shift and go to state 226
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 192

    (45) object_literal -> LBRACE property_assignment_list RBRACE .

    SEMICOLON       reduce using rule 45 (object_literal -> LBRACE property_assignment_list RBRACE .)
    RPAREN          reduce using rule 45 (object_literal -> LBRACE property_assignment_list RBRACE .)
    COMMA           reduce using rule 45 (object_literal -> LBRACE property_assignment_list RBRACE .)
    RBRACKET        reduce using rule 45 (object_literal -> LBRACE property_assignment_list RBRACE .)
    RBRACE          reduce using rule 45 (object_literal -> LBRACE property_assignment_list RBRACE .)


state 193

    (48) property_assignment_list -> property_assignment COMMA . property_assignment_list
    (47) property_assignment_list -> . property_assignment
    (48) property_assignment_list -> . property_assignment COMMA property_assignment_list
    (49) property_assignment -> . IDENTIFIER COLON value
    (50) property_assignment -> . STRING COLON value

    IDENTIFIER      shift and go to state 150
    STRING          shift and go to state 151

    property_assignment            shift and go to state 149
    property_assignment_list       shift and go to state 227

state 194

    (49) property_assignment -> IDENTIFIER COLON . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 228
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 195

    (50) property_assignment -> STRING COLON . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 229
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 196

    (92) argument_list -> expression COMMA argument_list .

    RPAREN          reduce using rule 92 (argument_list -> expression COMMA argument_list .)


state 197

    (18) assignment -> CONST IDENTIFIER COLON data_type EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 230
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 198

    (20) assignment -> VAR IDENTIFIER COLON data_type EQUALS . value
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 231
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 199

    (109) assignment -> THIS DOT IDENTIFIER EQUALS value .

    SEMICOLON       reduce using rule 109 (assignment -> THIS DOT IDENTIFIER EQUALS value .)
    RPAREN          reduce using rule 109 (assignment -> THIS DOT IDENTIFIER EQUALS value .)


state 200

    (124) if_statement -> IF LPAREN logical_expression RPAREN statement_block .
    (125) if_statement -> IF LPAREN logical_expression RPAREN statement_block . ELSE statement_block

  ! shift/reduce conflict for ELSE resolved as shift
    LET             reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    CONST           reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    VAR             reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    IDENTIFIER      reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    THIS            reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    IF              reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    FUNCTION        reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    RETURN          reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    CLASS           reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    WHILE           reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    FOR             reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    BREAK           reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    CONTINUE        reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    NEW             reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    NOT             reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    TRUE            reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    FALSE           reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    LPAREN          reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    NUMBER          reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    $end            reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    RBRACE          reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .)
    ELSE            shift and go to state 232

  ! ELSE            [ reduce using rule 124 (if_statement -> IF LPAREN logical_expression RPAREN statement_block .) ]


state 201

    (119) statement_block -> LBRACE . statement_list RBRACE
    (2) statement_list -> . statement
    (3) statement_list -> . statement statement_list
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    statement_list                 shift and go to state 233
    statement                      shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 202

    (120) statement_block -> statement .

    ELSE            reduce using rule 120 (statement_block -> statement .)
    LET             reduce using rule 120 (statement_block -> statement .)
    CONST           reduce using rule 120 (statement_block -> statement .)
    VAR             reduce using rule 120 (statement_block -> statement .)
    IDENTIFIER      reduce using rule 120 (statement_block -> statement .)
    THIS            reduce using rule 120 (statement_block -> statement .)
    IF              reduce using rule 120 (statement_block -> statement .)
    FUNCTION        reduce using rule 120 (statement_block -> statement .)
    RETURN          reduce using rule 120 (statement_block -> statement .)
    CLASS           reduce using rule 120 (statement_block -> statement .)
    WHILE           reduce using rule 120 (statement_block -> statement .)
    FOR             reduce using rule 120 (statement_block -> statement .)
    BREAK           reduce using rule 120 (statement_block -> statement .)
    CONTINUE        reduce using rule 120 (statement_block -> statement .)
    NEW             reduce using rule 120 (statement_block -> statement .)
    NOT             reduce using rule 120 (statement_block -> statement .)
    TRUE            reduce using rule 120 (statement_block -> statement .)
    FALSE           reduce using rule 120 (statement_block -> statement .)
    LPAREN          reduce using rule 120 (statement_block -> statement .)
    NUMBER          reduce using rule 120 (statement_block -> statement .)
    $end            reduce using rule 120 (statement_block -> statement .)
    RBRACE          reduce using rule 120 (statement_block -> statement .)
    CONSTRUCTOR     reduce using rule 120 (statement_block -> statement .)


state 203

    (115) param_list -> IDENTIFIER COMMA . param_list
    (114) param_list -> . IDENTIFIER
    (115) param_list -> . IDENTIFIER COMMA param_list
    (116) param_list -> . IDENTIFIER COLON data_type
    (117) param_list -> . IDENTIFIER COLON data_type COMMA param_list

    IDENTIFIER      shift and go to state 161

    param_list                     shift and go to state 234

state 204

    (116) param_list -> IDENTIFIER COLON . data_type
    (117) param_list -> IDENTIFIER COLON . data_type COMMA param_list
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    ANY             shift and go to state 143
    LBRACE          shift and go to state 144

    data_type                      shift and go to state 235
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142

state 205

    (112) function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .

    LET             reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    CONST           reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    VAR             reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    IDENTIFIER      reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    THIS            reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    IF              reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    FUNCTION        reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    RETURN          reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    CLASS           reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    WHILE           reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    FOR             reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    BREAK           reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    CONTINUE        reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    NEW             reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    NOT             reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    TRUE            reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    FALSE           reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    LPAREN          reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    NUMBER          reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    $end            reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    RBRACE          reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)
    ELSE            reduce using rule 112 (function_def -> FUNCTION IDENTIFIER LPAREN RPAREN statement_block .)


state 206

    (113) function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    statement_block                shift and go to state 236
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 207

    (23) assignment -> IDENTIFIER COLON . value
    (105) class_property -> IDENTIFIER COLON . data_type SEMICOLON
    (106) class_property -> IDENTIFIER COLON . data_type EQUALS value SEMICOLON
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 238
    ANY             shift and go to state 143
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 97
    data_type                      shift and go to state 237
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 208

    (93) class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .

    LET             reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CONST           reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    VAR             reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    IDENTIFIER      reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    THIS            reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    IF              reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FUNCTION        reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    RETURN          reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CLASS           reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    WHILE           reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FOR             reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    BREAK           reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CONTINUE        reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    NEW             reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    NOT             reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    TRUE            reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    FALSE           reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    LPAREN          reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    NUMBER          reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    $end            reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    RBRACE          reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    ELSE            reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)
    CONSTRUCTOR     reduce using rule 93 (class_declaration -> CLASS IDENTIFIER LBRACE class_body RBRACE .)


state 209

    (99) class_member_list -> class_member class_member_list .

    RBRACE          reduce using rule 99 (class_member_list -> class_member class_member_list .)


state 210

    (100) class_member -> assignment SEMICOLON .

    LET             reduce using rule 100 (class_member -> assignment SEMICOLON .)
    CONST           reduce using rule 100 (class_member -> assignment SEMICOLON .)
    VAR             reduce using rule 100 (class_member -> assignment SEMICOLON .)
    IDENTIFIER      reduce using rule 100 (class_member -> assignment SEMICOLON .)
    THIS            reduce using rule 100 (class_member -> assignment SEMICOLON .)
    FUNCTION        reduce using rule 100 (class_member -> assignment SEMICOLON .)
    CONSTRUCTOR     reduce using rule 100 (class_member -> assignment SEMICOLON .)
    RBRACE          reduce using rule 100 (class_member -> assignment SEMICOLON .)


state 211

    (107) constructor -> CONSTRUCTOR LPAREN . RPAREN statement_block
    (108) constructor -> CONSTRUCTOR LPAREN . param_list RPAREN statement_block
    (114) param_list -> . IDENTIFIER
    (115) param_list -> . IDENTIFIER COMMA param_list
    (116) param_list -> . IDENTIFIER COLON data_type
    (117) param_list -> . IDENTIFIER COLON data_type COMMA param_list

    RPAREN          shift and go to state 239
    IDENTIFIER      shift and go to state 161

    param_list                     shift and go to state 240

state 212

    (121) while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .

    LET             reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    CONST           reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    VAR             reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    IDENTIFIER      reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    THIS            reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    IF              reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    FUNCTION        reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    RETURN          reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    CLASS           reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    WHILE           reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    FOR             reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    BREAK           reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    CONTINUE        reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    NEW             reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    NOT             reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    TRUE            reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    FALSE           reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    LPAREN          reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    NUMBER          reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    $end            reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    RBRACE          reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    ELSE            reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 121 (while_statement -> WHILE LPAREN logical_expression RPAREN statement_block .)


state 213

    (122) for_statement -> FOR LPAREN assignment SEMICOLON logical_expression . SEMICOLON assignment RPAREN statement_block
    (66) logical_expression -> logical_expression . AND logical_term
    (67) logical_expression -> logical_expression . OR logical_term

    SEMICOLON       shift and go to state 241
    AND             shift and go to state 64
    OR              shift and go to state 65


state 214

    (123) for_statement -> FOR LPAREN IDENTIFIER IN expression . RPAREN statement_block

    RPAREN          shift and go to state 242


state 215

    (109) assignment -> THIS DOT IDENTIFIER . EQUALS value

    EQUALS          shift and go to state 158


state 216

    (95) class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 95 (class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 95 (class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 95 (class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 95 (class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 95 (class_instantiation -> NEW IDENTIFIER LPAREN argument_list RPAREN .)


state 217

    (15) assignment -> LET IDENTIFIER COLON data_type EQUALS value .

    SEMICOLON       reduce using rule 15 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)
    RPAREN          reduce using rule 15 (assignment -> LET IDENTIFIER COLON data_type EQUALS value .)


state 218

    (36) array_type -> STRING_TYPE LBRACKET RBRACKET .

    EQUALS          reduce using rule 36 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 36 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    RPAREN          reduce using rule 36 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    COMMA           reduce using rule 36 (array_type -> STRING_TYPE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 36 (array_type -> STRING_TYPE LBRACKET RBRACKET .)


state 219

    (35) array_type -> NUMBER_TYPE LBRACKET RBRACKET .

    EQUALS          reduce using rule 35 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 35 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    RPAREN          reduce using rule 35 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    COMMA           reduce using rule 35 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 35 (array_type -> NUMBER_TYPE LBRACKET RBRACKET .)


state 220

    (37) array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .

    EQUALS          reduce using rule 37 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 37 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    RPAREN          reduce using rule 37 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    COMMA           reduce using rule 37 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)
    RBRACE          reduce using rule 37 (array_type -> BOOLEAN_TYPE LBRACKET RBRACKET .)


state 221

    (38) array_type -> ANY LBRACKET RBRACKET .

    EQUALS          reduce using rule 38 (array_type -> ANY LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 38 (array_type -> ANY LBRACKET RBRACKET .)
    RPAREN          reduce using rule 38 (array_type -> ANY LBRACKET RBRACKET .)
    COMMA           reduce using rule 38 (array_type -> ANY LBRACKET RBRACKET .)
    RBRACE          reduce using rule 38 (array_type -> ANY LBRACKET RBRACKET .)


state 222

    (43) object_type_literal -> LBRACE property_list RBRACE .

    EQUALS          reduce using rule 43 (object_type_literal -> LBRACE property_list RBRACE .)
    SEMICOLON       reduce using rule 43 (object_type_literal -> LBRACE property_list RBRACE .)
    RPAREN          reduce using rule 43 (object_type_literal -> LBRACE property_list RBRACE .)
    COMMA           reduce using rule 43 (object_type_literal -> LBRACE property_list RBRACE .)
    RBRACE          reduce using rule 43 (object_type_literal -> LBRACE property_list RBRACE .)


state 223

    (52) property_list -> property SEMICOLON . property_list
    (51) property_list -> . property
    (52) property_list -> . property SEMICOLON property_list
    (53) property_list -> . property COMMA property_list
    (46) property -> . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 189

    property                       shift and go to state 188
    property_list                  shift and go to state 243

state 224

    (53) property_list -> property COMMA . property_list
    (51) property_list -> . property
    (52) property_list -> . property SEMICOLON property_list
    (53) property_list -> . property COMMA property_list
    (46) property -> . IDENTIFIER COLON data_type

    IDENTIFIER      shift and go to state 189

    property                       shift and go to state 188
    property_list                  shift and go to state 244

state 225

    (46) property -> IDENTIFIER COLON . data_type
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE

    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    ANY             shift and go to state 143
    LBRACE          shift and go to state 144

    data_type                      shift and go to state 245
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142

state 226

    (42) element_list -> value COMMA element_list .

    RBRACKET        reduce using rule 42 (element_list -> value COMMA element_list .)


state 227

    (48) property_assignment_list -> property_assignment COMMA property_assignment_list .

    RBRACE          reduce using rule 48 (property_assignment_list -> property_assignment COMMA property_assignment_list .)


state 228

    (49) property_assignment -> IDENTIFIER COLON value .

    COMMA           reduce using rule 49 (property_assignment -> IDENTIFIER COLON value .)
    RBRACE          reduce using rule 49 (property_assignment -> IDENTIFIER COLON value .)


state 229

    (50) property_assignment -> STRING COLON value .

    COMMA           reduce using rule 50 (property_assignment -> STRING COLON value .)
    RBRACE          reduce using rule 50 (property_assignment -> STRING COLON value .)


state 230

    (18) assignment -> CONST IDENTIFIER COLON data_type EQUALS value .

    SEMICOLON       reduce using rule 18 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)
    RPAREN          reduce using rule 18 (assignment -> CONST IDENTIFIER COLON data_type EQUALS value .)


state 231

    (20) assignment -> VAR IDENTIFIER COLON data_type EQUALS value .

    SEMICOLON       reduce using rule 20 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)
    RPAREN          reduce using rule 20 (assignment -> VAR IDENTIFIER COLON data_type EQUALS value .)


state 232

    (125) if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    logical_expression             shift and go to state 20
    statement_block                shift and go to state 246
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 233

    (119) statement_block -> LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 247


state 234

    (115) param_list -> IDENTIFIER COMMA param_list .

    RPAREN          reduce using rule 115 (param_list -> IDENTIFIER COMMA param_list .)


state 235

    (116) param_list -> IDENTIFIER COLON data_type .
    (117) param_list -> IDENTIFIER COLON data_type . COMMA param_list

    RPAREN          reduce using rule 116 (param_list -> IDENTIFIER COLON data_type .)
    COMMA           shift and go to state 248


state 236

    (113) function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .

    LET             reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    CONST           reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    VAR             reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    IDENTIFIER      reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    THIS            reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    IF              reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    FUNCTION        reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    RETURN          reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    CLASS           reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    WHILE           reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    FOR             reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    BREAK           reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    CONTINUE        reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    NEW             reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    NOT             reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    TRUE            reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    FALSE           reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    LPAREN          reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    NUMBER          reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    $end            reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    RBRACE          reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)
    ELSE            reduce using rule 113 (function_def -> FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block .)


state 237

    (105) class_property -> IDENTIFIER COLON data_type . SEMICOLON
    (106) class_property -> IDENTIFIER COLON data_type . EQUALS value SEMICOLON

    SEMICOLON       shift and go to state 249
    EQUALS          shift and go to state 250


state 238

    (45) object_literal -> LBRACE . property_assignment_list RBRACE
    (43) object_type_literal -> LBRACE . property_list RBRACE
    (44) object_type_literal -> LBRACE . RBRACE
    (47) property_assignment_list -> . property_assignment
    (48) property_assignment_list -> . property_assignment COMMA property_assignment_list
    (51) property_list -> . property
    (52) property_list -> . property SEMICOLON property_list
    (53) property_list -> . property COMMA property_list
    (49) property_assignment -> . IDENTIFIER COLON value
    (50) property_assignment -> . STRING COLON value
    (46) property -> . IDENTIFIER COLON data_type

    RBRACE          shift and go to state 187
    IDENTIFIER      shift and go to state 251
    STRING          shift and go to state 151

    property_assignment_list       shift and go to state 148
    property_list                  shift and go to state 186
    property_assignment            shift and go to state 149
    property                       shift and go to state 188

state 239

    (107) constructor -> CONSTRUCTOR LPAREN RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    statement_block                shift and go to state 252
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 240

    (108) constructor -> CONSTRUCTOR LPAREN param_list . RPAREN statement_block

    RPAREN          shift and go to state 253


state 241

    (122) for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON . assignment RPAREN statement_block
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value

    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 255
    THIS            shift and go to state 129

    assignment                     shift and go to state 254

state 242

    (123) for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    expression                     shift and go to state 5
    statement_block                shift and go to state 256
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 243

    (52) property_list -> property SEMICOLON property_list .

    RBRACE          reduce using rule 52 (property_list -> property SEMICOLON property_list .)


state 244

    (53) property_list -> property COMMA property_list .

    RBRACE          reduce using rule 53 (property_list -> property COMMA property_list .)


state 245

    (46) property -> IDENTIFIER COLON data_type .

    SEMICOLON       reduce using rule 46 (property -> IDENTIFIER COLON data_type .)
    COMMA           reduce using rule 46 (property -> IDENTIFIER COLON data_type .)
    RBRACE          reduce using rule 46 (property -> IDENTIFIER COLON data_type .)


state 246

    (125) if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .

    LET             reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    CONST           reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    VAR             reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    IDENTIFIER      reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    THIS            reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    IF              reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    FUNCTION        reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    RETURN          reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    CLASS           reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    WHILE           reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    FOR             reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    BREAK           reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    CONTINUE        reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    NEW             reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    NOT             reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    TRUE            reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    FALSE           reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    LPAREN          reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    NUMBER          reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    $end            reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    RBRACE          reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    ELSE            reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)
    CONSTRUCTOR     reduce using rule 125 (if_statement -> IF LPAREN logical_expression RPAREN statement_block ELSE statement_block .)


state 247

    (119) statement_block -> LBRACE statement_list RBRACE .

    ELSE            reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    LET             reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    CONST           reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    VAR             reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    IDENTIFIER      reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    THIS            reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    FUNCTION        reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    CONTINUE        reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    NEW             reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    NUMBER          reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)
    CONSTRUCTOR     reduce using rule 119 (statement_block -> LBRACE statement_list RBRACE .)


state 248

    (117) param_list -> IDENTIFIER COLON data_type COMMA . param_list
    (114) param_list -> . IDENTIFIER
    (115) param_list -> . IDENTIFIER COMMA param_list
    (116) param_list -> . IDENTIFIER COLON data_type
    (117) param_list -> . IDENTIFIER COLON data_type COMMA param_list

    IDENTIFIER      shift and go to state 161

    param_list                     shift and go to state 257

state 249

    (105) class_property -> IDENTIFIER COLON data_type SEMICOLON .

    LET             reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    CONST           reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    VAR             reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    IDENTIFIER      reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    THIS            reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    FUNCTION        reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    CONSTRUCTOR     reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)
    RBRACE          reduce using rule 105 (class_property -> IDENTIFIER COLON data_type SEMICOLON .)


state 250

    (106) class_property -> IDENTIFIER COLON data_type EQUALS . value SEMICOLON
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 96
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 258
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 251

    (49) property_assignment -> IDENTIFIER . COLON value
    (46) property -> IDENTIFIER . COLON data_type

    COLON           shift and go to state 259


state 252

    (107) constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .

    LET             reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    CONST           reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    VAR             reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    IDENTIFIER      reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    THIS            reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    FUNCTION        reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)
    RBRACE          reduce using rule 107 (constructor -> CONSTRUCTOR LPAREN RPAREN statement_block .)


state 253

    (108) constructor -> CONSTRUCTOR LPAREN param_list RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    statement_block                shift and go to state 260
    statement                      shift and go to state 202
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 254

    (122) for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment . RPAREN statement_block

    RPAREN          shift and go to state 261


state 255

    (22) assignment -> IDENTIFIER . EQUALS value
    (23) assignment -> IDENTIFIER . COLON value

    EQUALS          shift and go to state 49
    COLON           shift and go to state 50


state 256

    (123) for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .

    LET             reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    CONST           reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    VAR             reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    IDENTIFIER      reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    THIS            reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    IF              reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    FUNCTION        reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    RETURN          reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    CLASS           reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    WHILE           reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    FOR             reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    BREAK           reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    CONTINUE        reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    NEW             reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    NOT             reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    TRUE            reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    FALSE           reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    LPAREN          reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    NUMBER          reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    $end            reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    RBRACE          reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    ELSE            reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 123 (for_statement -> FOR LPAREN IDENTIFIER IN expression RPAREN statement_block .)


state 257

    (117) param_list -> IDENTIFIER COLON data_type COMMA param_list .

    RPAREN          reduce using rule 117 (param_list -> IDENTIFIER COLON data_type COMMA param_list .)


state 258

    (106) class_property -> IDENTIFIER COLON data_type EQUALS value . SEMICOLON

    SEMICOLON       shift and go to state 262


state 259

    (49) property_assignment -> IDENTIFIER COLON . value
    (46) property -> IDENTIFIER COLON . data_type
    (30) value -> . STRING
    (31) value -> . CHARACTER
    (32) value -> . array
    (33) value -> . object_literal
    (34) value -> . expression
    (24) data_type -> . STRING_TYPE
    (25) data_type -> . NUMBER_TYPE
    (26) data_type -> . BOOLEAN_TYPE
    (27) data_type -> . CHAR_TYPE
    (28) data_type -> . array_type
    (29) data_type -> . object_type_literal
    (39) array -> . LBRACKET RBRACKET
    (40) array -> . LBRACKET element_list RBRACKET
    (45) object_literal -> . LBRACE property_assignment_list RBRACE
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (35) array_type -> . NUMBER_TYPE LBRACKET RBRACKET
    (36) array_type -> . STRING_TYPE LBRACKET RBRACKET
    (37) array_type -> . BOOLEAN_TYPE LBRACKET RBRACKET
    (38) array_type -> . ANY LBRACKET RBRACKET
    (43) object_type_literal -> . LBRACE property_list RBRACE
    (44) object_type_literal -> . LBRACE RBRACE
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    STRING          shift and go to state 90
    CHARACTER       shift and go to state 91
    STRING_TYPE     shift and go to state 137
    NUMBER_TYPE     shift and go to state 138
    BOOLEAN_TYPE    shift and go to state 139
    CHAR_TYPE       shift and go to state 140
    LBRACKET        shift and go to state 95
    LBRACE          shift and go to state 238
    ANY             shift and go to state 143
    IDENTIFIER      shift and go to state 73
    NEW             shift and go to state 36
    THIS            shift and go to state 74
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    value                          shift and go to state 228
    data_type                      shift and go to state 245
    array                          shift and go to state 92
    object_literal                 shift and go to state 93
    expression                     shift and go to state 94
    array_type                     shift and go to state 141
    object_type_literal            shift and go to state 142
    arithmetic_expression          shift and go to state 19
    logical_expression             shift and go to state 20
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 260

    (108) constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .

    LET             reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    CONST           reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    VAR             reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    IDENTIFIER      reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    THIS            reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    FUNCTION        reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)
    RBRACE          reduce using rule 108 (constructor -> CONSTRUCTOR LPAREN param_list RPAREN statement_block .)


state 261

    (122) for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN . statement_block
    (119) statement_block -> . LBRACE statement_list RBRACE
    (120) statement_block -> . statement
    (4) statement -> . assignment SEMICOLON
    (5) statement -> . expression SEMICOLON
    (6) statement -> . if_statement
    (7) statement -> . function_def
    (8) statement -> . return_statement
    (9) statement -> . class_declaration
    (10) statement -> . while_statement
    (11) statement -> . for_statement
    (12) statement -> . break_statement
    (13) statement -> . continue_statement
    (14) assignment -> . LET IDENTIFIER EQUALS value
    (15) assignment -> . LET IDENTIFIER COLON data_type EQUALS value
    (16) assignment -> . LET IDENTIFIER COLON data_type
    (17) assignment -> . CONST IDENTIFIER EQUALS value
    (18) assignment -> . CONST IDENTIFIER COLON data_type EQUALS value
    (19) assignment -> . VAR IDENTIFIER EQUALS value
    (20) assignment -> . VAR IDENTIFIER COLON data_type EQUALS value
    (21) assignment -> . VAR IDENTIFIER COLON data_type
    (22) assignment -> . IDENTIFIER EQUALS value
    (23) assignment -> . IDENTIFIER COLON value
    (109) assignment -> . THIS DOT IDENTIFIER EQUALS value
    (81) expression -> . arithmetic_expression
    (82) expression -> . logical_expression
    (83) expression -> . member_access
    (84) expression -> . function_call
    (85) expression -> . class_instantiation
    (86) expression -> . this_access
    (124) if_statement -> . IF LPAREN logical_expression RPAREN statement_block
    (125) if_statement -> . IF LPAREN logical_expression RPAREN statement_block ELSE statement_block
    (112) function_def -> . FUNCTION IDENTIFIER LPAREN RPAREN statement_block
    (113) function_def -> . FUNCTION IDENTIFIER LPAREN param_list RPAREN statement_block
    (118) return_statement -> . RETURN expression SEMICOLON
    (93) class_declaration -> . CLASS IDENTIFIER LBRACE class_body RBRACE
    (121) while_statement -> . WHILE LPAREN logical_expression RPAREN statement_block
    (122) for_statement -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block
    (123) for_statement -> . FOR LPAREN IDENTIFIER IN expression RPAREN statement_block
    (126) break_statement -> . BREAK SEMICOLON
    (127) continue_statement -> . CONTINUE SEMICOLON
    (54) arithmetic_expression -> . arithmetic_expression PLUS term
    (55) arithmetic_expression -> . arithmetic_expression MINUS term
    (56) arithmetic_expression -> . term
    (66) logical_expression -> . logical_expression AND logical_term
    (67) logical_expression -> . logical_expression OR logical_term
    (68) logical_expression -> . logical_term
    (87) member_access -> . member_access DOT IDENTIFIER
    (88) member_access -> . IDENTIFIER DOT IDENTIFIER
    (89) function_call -> . IDENTIFIER LPAREN RPAREN
    (90) function_call -> . IDENTIFIER LPAREN argument_list RPAREN
    (94) class_instantiation -> . NEW IDENTIFIER LPAREN RPAREN
    (95) class_instantiation -> . NEW IDENTIFIER LPAREN argument_list RPAREN
    (110) this_access -> . THIS DOT IDENTIFIER
    (111) this_access -> . THIS
    (57) term -> . term TIMES factor
    (58) term -> . term DIVIDE factor
    (59) term -> . term MODULE factor
    (60) term -> . factor
    (69) logical_term -> . NOT logical_factor
    (70) logical_term -> . logical_factor
    (61) factor -> . atom POWER factor
    (62) factor -> . atom
    (71) logical_factor -> . comparison_expression
    (72) logical_factor -> . TRUE
    (73) logical_factor -> . FALSE
    (74) logical_factor -> . LPAREN logical_expression RPAREN
    (63) atom -> . NUMBER
    (64) atom -> . IDENTIFIER
    (65) atom -> . LPAREN arithmetic_expression RPAREN
    (75) comparison_expression -> . arithmetic_expression EQEQ arithmetic_expression
    (76) comparison_expression -> . arithmetic_expression NOTEQ arithmetic_expression
    (77) comparison_expression -> . arithmetic_expression GT arithmetic_expression
    (78) comparison_expression -> . arithmetic_expression LT arithmetic_expression
    (79) comparison_expression -> . arithmetic_expression GE arithmetic_expression
    (80) comparison_expression -> . arithmetic_expression LE arithmetic_expression

    LBRACE          shift and go to state 201
    LET             shift and go to state 14
    CONST           shift and go to state 16
    VAR             shift and go to state 17
    IDENTIFIER      shift and go to state 15
    THIS            shift and go to state 18
    IF              shift and go to state 25
    FUNCTION        shift and go to state 27
    RETURN          shift and go to state 28
    CLASS           shift and go to state 29
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    BREAK           shift and go to state 32
    CONTINUE        shift and go to state 33
    NEW             shift and go to state 36
    NOT             shift and go to state 38
    TRUE            shift and go to state 42
    FALSE           shift and go to state 43
    LPAREN          shift and go to state 26
    NUMBER          shift and go to state 44

    assignment                     shift and go to state 4
    logical_expression             shift and go to state 20
    statement_block                shift and go to state 263
    statement                      shift and go to state 202
    expression                     shift and go to state 5
    if_statement                   shift and go to state 6
    function_def                   shift and go to state 7
    return_statement               shift and go to state 8
    class_declaration              shift and go to state 9
    while_statement                shift and go to state 10
    for_statement                  shift and go to state 11
    break_statement                shift and go to state 12
    continue_statement             shift and go to state 13
    arithmetic_expression          shift and go to state 19
    member_access                  shift and go to state 21
    function_call                  shift and go to state 22
    class_instantiation            shift and go to state 23
    this_access                    shift and go to state 24
    term                           shift and go to state 34
    logical_term                   shift and go to state 35
    factor                         shift and go to state 37
    logical_factor                 shift and go to state 39
    atom                           shift and go to state 40
    comparison_expression          shift and go to state 41

state 262

    (106) class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .

    LET             reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    CONST           reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    VAR             reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    IDENTIFIER      reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    THIS            reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    FUNCTION        reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    CONSTRUCTOR     reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)
    RBRACE          reduce using rule 106 (class_property -> IDENTIFIER COLON data_type EQUALS value SEMICOLON .)


state 263

    (122) for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .

    LET             reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    CONST           reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    VAR             reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    IDENTIFIER      reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    THIS            reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    IF              reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    FUNCTION        reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    RETURN          reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    CLASS           reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    WHILE           reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    FOR             reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    BREAK           reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    CONTINUE        reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    NEW             reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    NOT             reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    TRUE            reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    FALSE           reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    LPAREN          reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    NUMBER          reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    $end            reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    RBRACE          reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    ELSE            reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)
    CONSTRUCTOR     reduce using rule 122 (for_statement -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN statement_block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 200 resolved as shift
